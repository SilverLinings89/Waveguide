<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="class_dual_problem_transformation_wrapper">
<title>DualProblemTransformationWrapper class Reference</title>
<para>
    <programlisting>#include <link linkend="_dual_problem_transformation_wrapper_8h">&lt;DualProblemTransformationWrapper.h&gt;</link></programlisting>
</para>
        <section>
            <title>Public Attributes</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double XMinus</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double XPlus</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double YMinus</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double YPlus</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double ZMinus</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double ZPlus</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; Sector&lt; 3 &gt; &gt; case_sectors<para><emphasis>This member contains all the Sectors who, as a sum, form the complete
Waveguide.</emphasis></para></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double epsilon_K<para><emphasis>The material-property \form#41 has a different value inside and
outside of the waveguides core.</emphasis></para></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double epsilon_M<para><emphasis>The material-property \form#41 has a different value inside and
outside of the waveguides core.</emphasis></para></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const int sectors<para><emphasis>Since the computational domain is split into subdomains (called sectors),
it is important to keep track of the amount of subdomains.</emphasis></para></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const double deltaY<para><emphasis>This value is initialized with the value Delta from the input-file.</emphasis></para></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Vector&lt; double &gt; InitialDofs<para><emphasis>This vector of values saves the initial configuration.</emphasis></para></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>SpaceTransformation * st</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="class_dual_problem_transformation_wrapper_1a1d2648b23d41e2b6e37143ee90635466">DualProblemTransformationWrapper</link> (
<link linkend="class_space_transformation">SpaceTransformation</link> * non_dual_st, int rank)<para><emphasis>Since this object encapsulates another Space Transformation, the
construction is straight forward.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="class_dual_problem_transformation_wrapper_1a51d51d595309eeba3ec72a3630cf5f45">~DualProblemTransformationWrapper</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Point&lt; 3 &gt; <link linkend="class_dual_problem_transformation_wrapper_1a396d2c6c52647113e925ea61907d6e3e">math_to_phys</link> (
Point&lt; 3 &gt; coord)<para><emphasis>One of the core functionalities of a SpaceTransformation is to map a
mathematical coordinate to a physical one (so an transformed to an
untransformed coordinate).</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Point&lt; 3 &gt; <link linkend="class_dual_problem_transformation_wrapper_1a0bd0e5489971d2a9c896b5a61b76a147">phys_to_math</link> (
Point&lt; 3 &gt; coord)<para><emphasis>This function does the same as math_to_phys only in the opposit direction.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_dual_problem_transformation_wrapper_1a9660c1aded65b922d9ffed9a6f8fe334">is_identity</link> (
Point&lt; 3 &gt; coord)<para><emphasis>In order to test implementation, this function was added to check, if the
transformation-tensor at a given coordinate is the identity or not.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; <link linkend="class_dual_problem_transformation_wrapper_1a1266c2a280f5b1c79074129ffff94ce4">get_Tensor</link> (
Point&lt; 3 &gt; &amp; coordinate)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; <link linkend="class_dual_problem_transformation_wrapper_1a04f9817636c3186a2744b3a0adb68162">get_Preconditioner_Tensor</link> (
Point&lt; 3 &gt; &amp; coordinate, int block)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; <link linkend="class_dual_problem_transformation_wrapper_1ab091ab780418511427cd27a9076885a4">Apply_PML_To_Tensor</link> (
Point&lt; 3 &gt; &amp; coordinate, Tensor&lt; 2, 3, double &gt; Tensor_input)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; <link linkend="class_dual_problem_transformation_wrapper_1a752cac789d32bcc51523cfb7c807d6f3">Apply_PML_To_Tensor_For_Preconditioner</link> (
Point&lt; 3 &gt; &amp; coordinate, Tensor&lt; 2, 3, double &gt; Tensor_input, int block)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, double &gt; <link linkend="class_dual_problem_transformation_wrapper_1ac457ef5d202bb8f32873e1cc9fe0d2fe">get_Space_Transformation_Tensor</link> (
Point&lt; 3 &gt; &amp; coordinate)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, double &gt; <link linkend="class_dual_problem_transformation_wrapper_1acb366b831687e15cd6d44f1e0819f179">get_Space_Transformation_Tensor_Homogenized</link> (
Point&lt; 3 &gt; &amp; coordinate)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_dual_problem_transformation_wrapper_1a42c9e2b2f97335a79215b451d8127393">PML_in_X</link> (
Point&lt; 3 &gt; &amp; position)<para><emphasis>This function is used to determine, if a system-coordinate belongs to a
PML-region for the PML that limits the computational domain along the
x-axis.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_dual_problem_transformation_wrapper_1acdab60b2be55a17ed803429ad918afd9">PML_in_Y</link> (
Point&lt; 3 &gt; &amp; position)<para><emphasis>This function is used to determine, if a system-coordinate belongs to a
PML-region for the PML that limits the computational domain along the
y-axis.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_dual_problem_transformation_wrapper_1aee0f3b90b0a9d27d737e8527b4cd72c6">PML_in_Z</link> (
Point&lt; 3 &gt; &amp; position)<para><emphasis>This function is used to determine, if a system-coordinate belongs to a
PML-region for the PML that limits the computational domain along the
z-axis.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1ac3ee8ebbc8076b7f26625c277e0438a9">Preconditioner_PML_Z_Distance</link> (
Point&lt; 3 &gt; &amp; p, unsigned int block)<para><emphasis>This function fulfills the same purpose as those with similar names but it
is supposed to be used together with Preconditioner_PML_in_Z instead of the
versions without &quot;Preconditioner&quot;.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1af794a155978190a27867aded190e7cf1">PML_X_Distance</link> (
Point&lt; 3 &gt; &amp; position)<para><emphasis>This function calculates for a given point, its distance to a PML-boundary
limiting the computational domain.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1aed8dcf1d8ad07a76075950ab850d8134">PML_Y_Distance</link> (
Point&lt; 3 &gt; &amp; position)<para><emphasis>This function calculates for a given point, its distance to a PML-boundary
limiting the computational domain.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1ac51b240160996ecbdd5126e3ca026d4c">PML_Z_Distance</link> (
Point&lt; 3 &gt; &amp; position)<para><emphasis>This function calculates for a given point, its distance to a PML-boundary
limiting the computational domain.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_dual_problem_transformation_wrapper_1a2e1f0e551e73ade4d59c9f74ab04db6f">estimate_and_initialize</link> (
)<para><emphasis>At the beginning (before the first solution of a system) only the boundary
conditions for the shape of the waveguide are known.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a4b78dd8311616a69c95f0b23ff17dea7">get_Q1</link> (
double z)<para><emphasis>This member calculates the value of Q1 for a provided \form#42-coordinate.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a5fb013593a2be7b05cad9d2fd881a471">get_Q2</link> (
double z)<para><emphasis>This member calculates the value of Q2 for a provided \form#42-coordinate.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a8ef6b10638782b2b0bbf3e5d8e75c700">get_Q3</link> (
double z)<para><emphasis>This member calculates the value of Q3 for a provided \form#42-coordinate.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1afb68509aedf69ca86444bfa803b87786">get_dof</link> (
int dof)<para><emphasis>This is a getter for the values of degrees of freedom.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_dual_problem_transformation_wrapper_1a80f70f69858d7d099ab33c8967ec8ff1">set_dof</link> (
int dof, double value)<para><emphasis>This function sets the value of the dof provided to the given value.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a6bffcebf18db8637aa5137a0f5c9776b">get_free_dof</link> (
int dof)<para><emphasis>This is a getter for the values of degrees of freedom.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_dual_problem_transformation_wrapper_1a99850a3e741eb1ae36555da9c0bd32a7">set_free_dof</link> (
int dof, double value)<para><emphasis>This function sets the value of the dof provided to the given value.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::pair&lt; int, double &gt; <link linkend="class_dual_problem_transformation_wrapper_1ab2847eaf645962d538d754bf384ba6e7">Z_to_Sector_and_local_z</link> (
double in_z)<para><emphasis>Using this method unifies the usage of coordinates.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a9e2cb7b59d07e77ba849fbb0e49ab2ab">System_Length</link> (
)<para><emphasis>Returns the complete length of the computational domain.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a702704a446a3c7f4c8fdaca5c3e657a6">Sector_Length</link> (
)<para><emphasis>Returns the length of one sector.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1af98bc0dee71952c46d9debe26fdf0e98">Layer_Length</link> (
)<para><emphasis>Returns the length of one layer.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1aecdb825d49428ed9902c369e58f39e60">get_r</link> (
double in_z)<para><emphasis>Returns the radius for a system-coordinate;.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a7287bf478379812a2ed66036f25369ff">get_m</link> (
double in_z)<para><emphasis>Returns the shift for a system-coordinate;.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_dual_problem_transformation_wrapper_1a522e6ffb1b6d95c82cc3aa1754a37938">get_v</link> (
double in_z)<para><emphasis>Returns the tilt for a system-coordinate;.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int <link linkend="class_dual_problem_transformation_wrapper_1a6204a80f508945858bca267eae802f62">Z_to_Layer</link> (
double )</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Vector&lt; double &gt; <link linkend="class_dual_problem_transformation_wrapper_1ac54096a316092fdeca64a1b5d59247a4">Dofs</link> (
)<para><emphasis>Other objects can use this function to retrieve an array of the current
values of the degrees of freedom of the functional we are optimizing.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>unsigned int <link linkend="class_dual_problem_transformation_wrapper_1aa107c5fb31f7161339e40a52b2cf080c">NFreeDofs</link> (
)<para><emphasis>This function returns the number of unrestrained degrees of freedom of the
current optimization run.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>unsigned int <link linkend="class_dual_problem_transformation_wrapper_1aacdefda799c91102c06be95b42702cd7">NDofs</link> (
)<para><emphasis>This function returns the total number of DOFs including restrained ones.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool <link linkend="class_dual_problem_transformation_wrapper_1a916e000000913063601cd3935d6ed257">IsDofFree</link> (
int )<para><emphasis>Since Dofs() also returns restrained degrees of freedom, this function can
be applied to determine if a degree of freedom is indeed free or
restrained.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_dual_problem_transformation_wrapper_1a113fb6e5d2b64bda4dbd20c3399be7e5">Print</link> (
)<para><emphasis>Console output of the current Waveguide Structure.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::complex&lt; double &gt; <link linkend="class_dual_problem_transformation_wrapper_1a5f744cc44e1193289c1e3ef9f72b91fe">evaluate_for_z</link> (
double , <link linkend="class_waveguide">Waveguide</link> * )<para><emphasis>Since the Wavegudie itself may be circular or rectangular now, the
evaluation routines should be moved to a point in the code where this
information is included in the code.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::complex&lt; double &gt; <link linkend="class_dual_problem_transformation_wrapper_1a16373d16a2eecae18e4deb5448bb20b5">evaluate_for_z_with_sum</link> (
double , double , <link linkend="class_waveguide">Waveguide</link> * )</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::complex&lt; double &gt; <link linkend="class_dual_problem_transformation_wrapper_1ad42a2488109c474f8871f23da57a27f2">gauss_product_2D_sphere</link> (
double z, int n, double R, double Xc, double Yc, <link linkend="class_waveguide">Waveguide</link> * in_w)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>

<para>If we do an adjoint computation, we need a <link linkend="class_space_transformation">SpaceTransformation</link>, which has the same properties as the primal one but measures in transformed coordinates. </para>
    </simplesect>
        <simplesect>
            <title>Detailed Description</title>

<para>This Wrapper contains the space transformation of the primal version but maps input parameters to their dual equivalent.</para>

<para>Essentially this class enables us to write a waveguide class which is unaware of its being primal or dual. Using this wrapper makes us compute the solution of the inverse order shape parametrization. <formalpara><title>Author: </title>

<para>Pascal Kraft </para>
</formalpara>
<formalpara><title>Date: </title>

<para>1.12.2016 </para>
</formalpara>
</para>
                <para>Definition at line 26 of file DualProblemTransformationWrapper.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>DualProblemTransformationWrapper.h</para></listitem></itemizedlist></para>
        </simplesect>
        <section>
            <title>Member Data Documentation</title>
            <simplesect>
                <title>std::vector&lt;Sector&lt;3&gt; &gt; DualProblemTransformationWrapper::case_sectors</title>                
<para>These Sectors are a partition of the simulated domain. </para>

                <para>Definition at line 151 of file DualProblemTransformationWrapper.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>DualProblemTransformationWrapper.h</para></listitem></itemizedlist></para>
            </simplesect>
            <simplesect>
                <title>const double DualProblemTransformationWrapper::epsilon_K</title>                
<para>This variable stores its value inside the core. </para>

                <para>Definition at line 158 of file DualProblemTransformationWrapper.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>DualProblemTransformationWrapper.h</para></listitem></itemizedlist></para>
            </simplesect>
            <simplesect>
                <title>const double DualProblemTransformationWrapper::epsilon_M</title>                
<para>This variable stores its value outside the core. </para>

                <para>Definition at line 164 of file DualProblemTransformationWrapper.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>DualProblemTransformationWrapper.h</para></listitem></itemizedlist></para>
            </simplesect>
            <simplesect>
                <title>const int DualProblemTransformationWrapper::sectors</title>                
<para>This member stores the number of Sectors the computational domain has been split into. </para>

                <para>Definition at line 170 of file DualProblemTransformationWrapper.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>DualProblemTransformationWrapper.h</para></listitem></itemizedlist></para>
            </simplesect>
        </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a1d2648b23d41e2b6e37143ee90635466">
                <title>DualProblemTransformationWrapper::DualProblemTransformationWrapper (SpaceTransformation *non_dual_st, int rank)</title> <emphasis>Since this object encapsulates another Space Transformation, the
construction is straight forward.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>non_dual_st</entry>
                                <entry>
<para>This pointer points to the actual transformation that is being wrapped. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a51d51d595309eeba3ec72a3630cf5f45">
                <title>DualProblemTransformationWrapper::~DualProblemTransformationWrapper ()</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a396d2c6c52647113e925ea61907d6e3e">
                <title>Point&lt; 3 &gt; DualProblemTransformationWrapper::math_to_phys (Point&lt; 3 &gt; coord) const</title> <emphasis>One of the core functionalities of a SpaceTransformation is to map a
mathematical coordinate to a physical one (so an transformed to an
untransformed coordinate).</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>coord</entry>
                                <entry>
<para>the coordinate to be transformed. In this class we simply pass the </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a0bd0e5489971d2a9c896b5a61b76a147">
                <title>Point&lt; 3 &gt; DualProblemTransformationWrapper::phys_to_math (Point&lt; 3 &gt; coord) const</title> <emphasis>This function does the same as math_to_phys only in the opposit direction.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>coord</entry>
                                <entry>
<para>the coordinate to be transformed. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a9660c1aded65b922d9ffed9a6f8fe334">
                <title>bool DualProblemTransformationWrapper::is_identity (Point&lt; 3 &gt; coord) const</title> <emphasis>In order to test implementation, this function was added to check, if the
transformation-tensor at a given coordinate is the identity or not.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>coord</entry>
                                <entry>
<para>This is the coordinate to test. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a1266c2a280f5b1c79074129ffff94ce4">
                <title>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; DualProblemTransformationWrapper::get_Tensor (Point&lt; 3 &gt; &amp;coordinate) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a04f9817636c3186a2744b3a0adb68162">
                <title>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; DualProblemTransformationWrapper::get_Preconditioner_Tensor (Point&lt; 3 &gt; &amp;coordinate, int block) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ab091ab780418511427cd27a9076885a4">
                <title>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; DualProblemTransformationWrapper::Apply_PML_To_Tensor (Point&lt; 3 &gt; &amp;coordinate, Tensor&lt; 2, 3, double &gt; Tensor_input) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a752cac789d32bcc51523cfb7c807d6f3">
                <title>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; DualProblemTransformationWrapper::Apply_PML_To_Tensor_For_Preconditioner (Point&lt; 3 &gt; &amp;coordinate, Tensor&lt; 2, 3, double &gt; Tensor_input, int block) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ac457ef5d202bb8f32873e1cc9fe0d2fe">
                <title>Tensor&lt; 2, 3, double &gt; DualProblemTransformationWrapper::get_Space_Transformation_Tensor (Point&lt; 3 &gt; &amp;coordinate) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1acb366b831687e15cd6d44f1e0819f179">
                <title>Tensor&lt; 2, 3, double &gt; DualProblemTransformationWrapper::get_Space_Transformation_Tensor_Homogenized (Point&lt; 3 &gt; &amp;coordinate) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a42c9e2b2f97335a79215b451d8127393">
                <title>bool DualProblemTransformationWrapper::PML_in_X (Point&lt; 3 &gt; &amp;position) const</title> <emphasis>This function is used to determine, if a system-coordinate belongs to a
PML-region for the PML that limits the computational domain along the
x-axis.</emphasis>
                
<para>Since there are 3 blocks of PML-type material, there are 3 functions. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>position</entry>
                                <entry>
<para>Stores the position in which to test for presence of a PML-Material. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1acdab60b2be55a17ed803429ad918afd9">
                <title>bool DualProblemTransformationWrapper::PML_in_Y (Point&lt; 3 &gt; &amp;position) const</title> <emphasis>This function is used to determine, if a system-coordinate belongs to a
PML-region for the PML that limits the computational domain along the
y-axis.</emphasis>
                
<para>Since there are 3 blocks of PML-type material, there are 3 functions. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>position</entry>
                                <entry>
<para>Stores the position in which to test for presence of a PML-Material. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1aee0f3b90b0a9d27d737e8527b4cd72c6">
                <title>bool DualProblemTransformationWrapper::PML_in_Z (Point&lt; 3 &gt; &amp;position) const</title> <emphasis>This function is used to determine, if a system-coordinate belongs to a
PML-region for the PML that limits the computational domain along the
z-axis.</emphasis>
                
<para>Since there are 3 blocks of PML-type material, there are 3 functions. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>position</entry>
                                <entry>
<para>Stores the position in which to test for presence of a PML-Material. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ac3ee8ebbc8076b7f26625c277e0438a9">
                <title>double DualProblemTransformationWrapper::Preconditioner_PML_Z_Distance (Point&lt; 3 &gt; &amp;p, unsigned int block) const</title> <emphasis>This function fulfills the same purpose as those with similar names but it
is supposed to be used together with Preconditioner_PML_in_Z instead of the
versions without &quot;Preconditioner&quot;.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1af794a155978190a27867aded190e7cf1">
                <title>double DualProblemTransformationWrapper::PML_X_Distance (Point&lt; 3 &gt; &amp;position) const</title> <emphasis>This function calculates for a given point, its distance to a PML-boundary
limiting the computational domain.</emphasis>
                
<para>This function is used merely to make code more readable. There is a function for every one of the dimensions since the normal vectors of PML-regions in this implementation are the coordinate-axis. This value is set to zero outside the PML and positive inside both PML-domains (only one for the z-direction). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>position</entry>
                                <entry>
<para>Stores the position from which to calculate the distance to the PML-surface. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1aed8dcf1d8ad07a76075950ab850d8134">
                <title>double DualProblemTransformationWrapper::PML_Y_Distance (Point&lt; 3 &gt; &amp;position) const</title> <emphasis>This function calculates for a given point, its distance to a PML-boundary
limiting the computational domain.</emphasis>
                
<para>This function is used merely to make code more readable. There is a function for every one of the dimensions since the normal vectors of PML-regions in this implementation are the coordinate-axis. This value is set to zero outside the PML and positive inside both PML-domains (only one for the z-direction). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>position</entry>
                                <entry>
<para>Stores the position from which to calculate the distance to the PML-surface. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ac51b240160996ecbdd5126e3ca026d4c">
                <title>double DualProblemTransformationWrapper::PML_Z_Distance (Point&lt; 3 &gt; &amp;position) const</title> <emphasis>This function calculates for a given point, its distance to a PML-boundary
limiting the computational domain.</emphasis>
                
<para>This function is used merely to make code more readable. There is a function for every one of the dimensions since the normal vectors of PML-regions in this implementation are the coordinate-axis. This value is set to zero outside the PML and positive inside both PML-domains (only one for the z-direction). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>position</entry>
                                <entry>
<para>Stores the position from which to calculate the distance to the PML-surface. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a2e1f0e551e73ade4d59c9f74ab04db6f">
                <title>void DualProblemTransformationWrapper::estimate_and_initialize ()</title> <emphasis>At the beginning (before the first solution of a system) only the boundary
conditions for the shape of the waveguide are known.</emphasis>
                
<para>Therefore the values for the degrees of freedom need to be estimated. This function sets all variables to appropiate values and estimates an appropriate shape based on averages and a polynomial interpolation of the boundary conditions on the shape. </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a4b78dd8311616a69c95f0b23ff17dea7">
                <title>double DualProblemTransformationWrapper::get_Q1 (double z) const</title> <emphasis>This member calculates the value of Q1 for a provided \form#42-coordinate.</emphasis>
                
<para>This value is used in the transformation of the solution-vector in transformed coordinates (solution of the system-matrix) to real coordinates (physical field). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>z</entry>
                                <entry>
<para>The value of Q1 is independent of <equation><title>form_43</title>$x$</equation> and <equation><title>form_44</title>$y$</equation>. Therefore only a <equation><title>form_42</title>$z$</equation>-coordinate is provided in a call to the function. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a5fb013593a2be7b05cad9d2fd881a471">
                <title>double DualProblemTransformationWrapper::get_Q2 (double z) const</title> <emphasis>This member calculates the value of Q2 for a provided \form#42-coordinate.</emphasis>
                
<para>This value is used in the transformation of the solution-vector in transformed coordinates (solution of the system-matrix) to real coordinates (physical field). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>z</entry>
                                <entry>
<para>The value of Q2 is independent of <equation><title>form_43</title>$x$</equation> and <equation><title>form_44</title>$y$</equation>. Therefore only a <equation><title>form_42</title>$z$</equation>-coordinate is provided in a call to the function. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a8ef6b10638782b2b0bbf3e5d8e75c700">
                <title>double DualProblemTransformationWrapper::get_Q3 (double z) const</title> <emphasis>This member calculates the value of Q3 for a provided \form#42-coordinate.</emphasis>
                
<para>This value is used in the transformation of the solution-vector in transformed coordinates (solution of the system-matrix) to real coordinates (physical field). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>z</entry>
                                <entry>
<para>The value of Q3 is independent of <equation><title>form_43</title>$x$</equation> and <equation><title>form_44</title>$y$</equation>. Therefore only a <equation><title>form_42</title>$z$</equation>-coordinate is provided in a call to the function. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1afb68509aedf69ca86444bfa803b87786">
                <title>double DualProblemTransformationWrapper::get_dof (int dof) const</title> <emphasis>This is a getter for the values of degrees of freedom.</emphasis>
                
<para>A getter-setter interface was introduced since the values are estimated automatically during the optimization and non-physical systems should be excluded from the domain of possible cases. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>dof</entry>
                                <entry>
<para>The index of the degree of freedom to be retrieved from the structure of the modelled waveguide. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>This function returns the value of the requested degree of freedom. Should this dof not exist, 0 will be returnd. </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a80f70f69858d7d099ab33c8967ec8ff1">
                <title>void DualProblemTransformationWrapper::set_dof (int dof, double value)</title> <emphasis>This function sets the value of the dof provided to the given value.</emphasis>
                
<para>It is important to consider, that some dofs are non-writable (i.e. the values of the degrees of freedom on the boundary, like the radius of the input-connector cannot be changed). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>dof</entry>
                                <entry>
<para>The index of the parameter to be changed. </para>
</entry>
                            </row>
                            <row>
                                <entry>value</entry>
                                <entry>
<para>The value, the dof should be set to. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a6bffcebf18db8637aa5137a0f5c9776b">
                <title>double DualProblemTransformationWrapper::get_free_dof (int dof) const</title> <emphasis>This is a getter for the values of degrees of freedom.</emphasis>
                
<para>A getter-setter interface was introduced since the values are estimated automatically during the optimization and non-physical systems should be excluded from the domain of possible cases. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>dof</entry>
                                <entry>
<para>The index of the degree of freedom to be retrieved from the structure of the modelled waveguide. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Returns: </title>

<para>This function returns the value of the requested degree of freedom. Should this dof not exist, 0 will be returnd. </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a99850a3e741eb1ae36555da9c0bd32a7">
                <title>void DualProblemTransformationWrapper::set_free_dof (int dof, double value)</title> <emphasis>This function sets the value of the dof provided to the given value.</emphasis>
                
<para>It is important to consider, that some dofs are non-writable (i.e. the values of the degrees of freedom on the boundary, like the radius of the input-connector cannot be changed). 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>dof</entry>
                                <entry>
<para>The index of the parameter to be changed. </para>
</entry>
                            </row>
                            <row>
                                <entry>value</entry>
                                <entry>
<para>The value, the dof should be set to. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ab2847eaf645962d538d754bf384ba6e7">
                <title>std::pair&lt; int, double &gt; DualProblemTransformationWrapper::Z_to_Sector_and_local_z (double in_z) const</title> <emphasis>Using this method unifies the usage of coordinates.</emphasis>
                
<para>This function takes a global <equation><title>form_42</title>$z$</equation> coordinate (in the computational domain) and returns both a Sector-Index and an internal <equation><title>form_42</title>$z$</equation> coordinate indicating which sector this coordinate belongs to and how far along in the sector it is located. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>double</entry>
                                <entry>
<para>in_z global system <equation><title>form_42</title>$z$</equation> coordinate for the transformation. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a9e2cb7b59d07e77ba849fbb0e49ab2ab">
                <title>double DualProblemTransformationWrapper::System_Length () const</title> <emphasis>Returns the complete length of the computational domain.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a702704a446a3c7f4c8fdaca5c3e657a6">
                <title>double DualProblemTransformationWrapper::Sector_Length () const</title> <emphasis>Returns the length of one sector.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1af98bc0dee71952c46d9debe26fdf0e98">
                <title>double DualProblemTransformationWrapper::Layer_Length () const</title> <emphasis>Returns the length of one layer.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1aecdb825d49428ed9902c369e58f39e60">
                <title>double DualProblemTransformationWrapper::get_r (double in_z) const</title> <emphasis>Returns the radius for a system-coordinate;.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a7287bf478379812a2ed66036f25369ff">
                <title>double DualProblemTransformationWrapper::get_m (double in_z) const</title> <emphasis>Returns the shift for a system-coordinate;.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a522e6ffb1b6d95c82cc3aa1754a37938">
                <title>double DualProblemTransformationWrapper::get_v (double in_z) const</title> <emphasis>Returns the tilt for a system-coordinate;.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a6204a80f508945858bca267eae802f62">
                <title>int DualProblemTransformationWrapper::Z_to_Layer (double) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ac54096a316092fdeca64a1b5d59247a4">
                <title>Vector&lt; double &gt; DualProblemTransformationWrapper::Dofs () const</title> <emphasis>Other objects can use this function to retrieve an array of the current
values of the degrees of freedom of the functional we are optimizing.</emphasis>
                
<para>This also includes restrained degrees of freedom and other functions can be used to determine this property. This has to be done because in different cases the number of restrained degrees of freedom can vary and we want no logic about this in other functions. </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1aa107c5fb31f7161339e40a52b2cf080c">
                <title>unsigned int DualProblemTransformationWrapper::NFreeDofs () const</title> <emphasis>This function returns the number of unrestrained degrees of freedom of the
current optimization run.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1aacdefda799c91102c06be95b42702cd7">
                <title>unsigned int DualProblemTransformationWrapper::NDofs () const</title> <emphasis>This function returns the total number of DOFs including restrained ones.</emphasis>
                
<para>This is the lenght of the array returned by <link linkend="class_dual_problem_transformation_wrapper_1ac54096a316092fdeca64a1b5d59247a4">Dofs()</link>. </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a916e000000913063601cd3935d6ed257">
                <title>bool DualProblemTransformationWrapper::IsDofFree (int) const</title> <emphasis>Since Dofs() also returns restrained degrees of freedom, this function can
be applied to determine if a degree of freedom is indeed free or
restrained.</emphasis>
                
<para>&quot;restrained&quot; means that for example the DOF represents the radius at one of the connectors (input or output) and therefore we forbid the optimization scheme to vary this value. </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a113fb6e5d2b64bda4dbd20c3399be7e5">
                <title>void DualProblemTransformationWrapper::Print () const</title> <emphasis>Console output of the current Waveguide Structure.</emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a5f744cc44e1193289c1e3ef9f72b91fe">
                <title>std::complex&lt; double &gt; DualProblemTransformationWrapper::evaluate_for_z (double z_in, Waveguide *)</title> <emphasis>Since the Wavegudie itself may be circular or rectangular now, the
evaluation routines should be moved to a point in the code where this
information is included in the code.</emphasis>
                
<para>Since I dont want to create derived classes from waveguide (which I should do eventually) I will for now include this functionality into the space transformation which is shape-sensitive. The waveguide only offers the evaluation at a point. The quadrature-rule has to be imposed by the space transformation. </para>

            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1a16373d16a2eecae18e4deb5448bb20b5">
                <title>std::complex&lt;double&gt; DualProblemTransformationWrapper::evaluate_for_z_with_sum (double, double, Waveguide *)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_dual_problem_transformation_wrapper_1ad42a2488109c474f8871f23da57a27f2">
                <title>std::complex&lt; double &gt; DualProblemTransformationWrapper::gauss_product_2D_sphere (double z, int n, double R, double Xc, double Yc, Waveguide *in_w)</title> <emphasis></emphasis>
                
            </section>
</section>
