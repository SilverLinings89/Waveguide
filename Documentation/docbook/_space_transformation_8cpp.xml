<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_space_transformation_8cpp">
    <title>SpaceTransformation.cpp File Reference</title>
    <programlisting>#include &quot;SpaceTransformation.h&quot;</programlisting>
    <programlisting>#include &lt;complex&gt;</programlisting>
    <programlisting>#include &lt;deal.II/base/point.h&gt;</programlisting>
    <programlisting>#include &lt;deal.II/base/tensor.h&gt;</programlisting>
    <programlisting>#include &lt;deal.II/lac/vector.h&gt;</programlisting>
    <programlisting>#include &quot;../Helpers/QuadratureFormulaCircle.cpp&quot;</programlisting>
    <programlisting>#include &quot;../Helpers/staticfunctions.h&quot;</programlisting>
    <programlisting>#include &quot;../Core/Sector.h&quot;</programlisting>
        <section>
            <title>Macros</title>
            <para>
                <itemizedlist>
                    <listitem>
                            <para>#define <link linkend="_space_transformation_8cpp_1a0329e49292456d3f2835b1021307ff8d">SpaceTransformation_CPP</link></para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>
        <title>Detailed Description</title>
    <para>Definition in file /home/kraft/workspace/waveguideproblem/Code/SpaceTransformations/SpaceTransformation.cpp</para>
    </simplesect>
    <literallayout><computeroutput>
1 <emphasis class="preprocessor">#ifndef&#32;SpaceTransformation_CPP</emphasis>
2 <emphasis class="preprocessor">#define&#32;SpaceTransformation_CPP</emphasis>
3 
4 <emphasis class="preprocessor">#include&#32;&quot;SpaceTransformation.h&quot;</emphasis>
5 <emphasis class="preprocessor">#include&#32;&lt;complex&gt;</emphasis>
6 <emphasis class="preprocessor">#include&#32;&lt;deal.II/base/point.h&gt;</emphasis>
7 <emphasis class="preprocessor">#include&#32;&lt;deal.II/base/tensor.h&gt;</emphasis>
8 <emphasis class="preprocessor">#include&#32;&lt;deal.II/lac/vector.h&gt;</emphasis>
9 <emphasis class="preprocessor">#include&#32;&quot;../Helpers/QuadratureFormulaCircle.cpp&quot;</emphasis>
10 <emphasis class="preprocessor">#include&#32;&quot;../Helpers/staticfunctions.h&quot;</emphasis>
11 <emphasis class="preprocessor">#include&#32;&quot;../Core/Sector.h&quot;</emphasis>
12 
<link linkend="class_space_transformation_1af9803c5e0dc6947ae08e428d3953e914">13 </link>std::pair&lt;int,&#32;double&gt;&#32;<link linkend="class_space_transformation_1af9803c5e0dc6947ae08e428d3953e914">SpaceTransformation::Z_to_Sector_and_local_z</link>(<emphasis class="keywordtype">double</emphasis>&#32;in_z)<emphasis class="keyword">&#32;const&#32;</emphasis>{
14 &#32;&#32;&#32;std::pair&lt;int,&#32;double&gt;&#32;ret;
15 &#32;&#32;&#32;&#32;ret.first&#32;=&#32;0;
16 &#32;&#32;&#32;&#32;ret.second&#32;=&#32;0.0;
17 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">if</emphasis>(in_z&#32;&lt;=&#32;-GlobalParams.M_R_ZLength/2.0)&#32;{
18 &#32;&#32;&#32;&#32;&#32;&#32;ret.first&#32;=&#32;0;
19 &#32;&#32;&#32;&#32;&#32;&#32;ret.second&#32;=&#32;0.0;
20 &#32;&#32;&#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;<emphasis class="keywordflow">if</emphasis>(abs(in_z)&#32;&lt;&#32;GlobalParams.M_R_ZLength/2.0)&#32;{
21 &#32;&#32;&#32;&#32;&#32;&#32;ret.first&#32;=&#32;floor((in_z&#32;+&#32;GlobalParams.M_R_ZLength/2.0)/&#32;(GlobalParams.SectorThickness));
22 &#32;&#32;&#32;&#32;&#32;&#32;ret.second&#32;=&#32;(in_z&#32;+&#32;GlobalParams.M_R_ZLength/2.0&#32;-&#32;(ret.first*GlobalParams.SectorThickness))/&#32;(GlobalParams.SectorThickness);
23 &#32;&#32;&#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;<emphasis class="keywordflow">if</emphasis>(in_z&#32;&gt;=&#32;GlobalParams.M_R_ZLength/2.0){
24 &#32;&#32;&#32;&#32;&#32;&#32;ret.first&#32;=&#32;<link linkend="class_space_transformation_1ad0b9c36e4f79b481638b5f7ef4914f50">sectors</link>&#32;-&#32;1;
25 &#32;&#32;&#32;&#32;&#32;&#32;ret.second&#32;=&#32;1.0;
26 &#32;&#32;&#32;&#32;}
27 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;ret;
28 }
29 
30 SpaceTransformation::SpaceTransformation(<emphasis class="keywordtype">int</emphasis>&#32;in_dofs_per_layer,&#32;<emphasis class="keywordtype">int</emphasis>&#32;in_rank)&#32;:
31 &#32;&#32;&#32;&#32;dofs_per_layer(in_dofs_per_layer),
32 &#32;&#32;&#32;&#32;boundary_dofs_in(in_dofs_per_layer),
33 &#32;&#32;&#32;&#32;boundary_dofs_out(in_dofs_per_layer),
34 &#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1acfc3ce47223489b9261ee69d4fec6661">epsilon_K</link>(GlobalParams.M_W_epsilonin),
35 &#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1a3cb9e63fe3d5c4436236bd6fee69d060">epsilon_M</link>(GlobalParams.M_W_epsilonout),
36 &#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1ad0b9c36e4f79b481638b5f7ef4914f50">sectors</link>(GlobalParams.M_W_Sectors),
37 &#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1a82a89fd12df1c0e1954c4a03115d2e42">deltaY</link>(GlobalParams.M_W_Delta),
38 &#32;&#32;&#32;&#32;rank(in_rank)
39 &#32;&#32;&#32;&#32;{
40 &#32;&#32;<link linkend="class_space_transformation_1a881cfdd7ec955dd57a2b463ed4707662">InitialQuality</link>&#32;=&#32;0;
41 }
42 
<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">43 </link><emphasis class="keywordtype">double</emphasis>&#32;<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">SpaceTransformation::Sector_Length</link>()<emphasis class="keyword">&#32;const&#32;</emphasis>{
44 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;GlobalParams.SectorThickness;
45 }
46 
<link linkend="class_space_transformation_1a5c01731c41adb0a9e7881f890a838a0c">47 </link><emphasis class="keywordtype">int</emphasis>&#32;<link linkend="class_space_transformation_1a5c01731c41adb0a9e7881f890a838a0c">SpaceTransformation::Z_to_Layer</link>(<emphasis class="keywordtype">double</emphasis>&#32;in_z)<emphasis class="keyword">&#32;const&#32;</emphasis>{
48 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;temp&#32;=&#32;(in_z&#32;-&#32;GlobalParams.Minimum_Z)/GlobalParams.LayerThickness;
49 &#32;&#32;<emphasis class="keywordtype">int</emphasis>&#32;flr&#32;=&#32;floor(temp);
50 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(flr&#32;==&#32;0)&#32;{
51 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;0;
52 &#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;{
53 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(temp&#32;-&#32;flr&#32;&lt;&#32;0.000001)&#32;{
54 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;flr-1;
55 &#32;&#32;&#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;{
56 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;flr;
57 &#32;&#32;&#32;&#32;}
58 &#32;&#32;}
59 }
60 
61 <emphasis class="keywordtype">bool</emphasis>&#32;SpaceTransformation::is_identity(Point&lt;3,&#32;double&gt;&#32;coord)<emphasis class="keyword">&#32;const&#32;</emphasis>{
62 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;sum&#32;=0.0;
63 &#32;&#32;Point&lt;3,double&gt;&#32;temp&#32;=&#32;math_to_phys(coord);
64 &#32;&#32;<emphasis class="keywordflow">for</emphasis>(<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;3;&#32;i++)&#32;{
65 &#32;&#32;&#32;&#32;sum&#32;+=&#32;std::abs(temp[i]&#32;-&#32;coord[i]);
66 &#32;&#32;}
67 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;sum&#32;&lt;&#32;0.0001;
68 }
69 
70 std::pair&lt;double,&#32;double&gt;&#32;SpaceTransformation::dof_support(<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;index)<emphasis class="keyword">&#32;const&#32;</emphasis>{
71 &#32;&#32;std::pair&lt;double,&#32;double&gt;&#32;ret;
72 &#32;&#32;ret.first&#32;=&#32;0.0;
73 &#32;&#32;ret.second&#32;=&#32;0.0;
74 &#32;&#32;<emphasis class="keywordtype">int</emphasis>&#32;boundary&#32;=&#32;index&#32;/&#32;dofs_per_layer;
75 &#32;&#32;ret.first&#32;=&#32;-&#32;GlobalParams.M_R_ZLength/2.0&#32;+&#32;(boundary&#32;-&#32;1)*&#32;<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">Sector_Length</link>();
76 &#32;&#32;ret.second&#32;=&#32;ret.first&#32;+&#32;2*<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">Sector_Length</link>();
77 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;ret;
78 }
79 
80 <emphasis class="keywordtype">bool</emphasis>&#32;SpaceTransformation::point_in_dof_support(Point&lt;3&gt;&#32;location,&#32;<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;dof_index)<emphasis class="keyword">&#32;const&#32;</emphasis>{
81 &#32;&#32;std::pair&lt;double,&#32;double&gt;&#32;temp&#32;=&#32;dof_support(dof_index);
82 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(std::abs(location[2])&#32;&gt;&#32;GlobalParams.M_R_ZLength/2.0)&#32;{
83 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;<emphasis class="keyword">false</emphasis>;
84 &#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;{
85 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;(temp.first&#32;&lt;=&#32;location[2]&#32;&amp;&amp;&#32;temp.second&#32;&gt;=&#32;location[2]);
86 &#32;&#32;}
87 }
88 
89 Tensor&lt;2,3,&#32;std::complex&lt;double&gt;&gt;&#32;SpaceTransformation::get_Tensor_for_step(Point&lt;3&gt;&#32;&amp;&#32;coordinate,&#32;<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;dof,&#32;<emphasis class="keywordtype">double</emphasis>&#32;step_width)&#32;{
90 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;old_value&#32;=&#32;<link linkend="class_space_transformation_1a7d3a0e5a6084d3ed2c11772147eb1297">get_dof</link>(dof);
91 &#32;&#32;Tensor&lt;2,3,double&gt;&#32;trafo&#32;=&#32;get_Space_Transformation_Tensor(coordinate);
92 
93 &#32;&#32;Tensor&lt;2,3,&#32;std::complex&lt;double&gt;&gt;&#32;original&#32;=&#32;Apply_PML_To_Tensor(coordinate,&#32;trafo);
94 &#32;&#32;<link linkend="class_space_transformation_1ae459d3c6f53143ec86773b87088cffcf">set_dof</link>(dof,&#32;old_value&#32;+&#32;step_width);
95 &#32;&#32;trafo&#32;=&#32;get_Space_Transformation_Tensor(coordinate);
96 &#32;&#32;Tensor&lt;2,3,&#32;std::complex&lt;double&gt;&gt;&#32;ret&#32;=&#32;Apply_PML_To_Tensor(coordinate,&#32;trafo);
97 &#32;&#32;<link linkend="class_space_transformation_1ae459d3c6f53143ec86773b87088cffcf">set_dof</link>(dof,&#32;old_value);
98 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;ret-original;
99 }
100 
101 std::complex&lt;double&gt;&#32;SpaceTransformation::gauss_product_2D_sphere(<emphasis class="keywordtype">double</emphasis>&#32;z,&#32;<emphasis class="keywordtype">int</emphasis>&#32;n,&#32;<emphasis class="keywordtype">double</emphasis>&#32;R,&#32;<emphasis class="keywordtype">double</emphasis>&#32;Xc,&#32;<emphasis class="keywordtype">double</emphasis>&#32;Yc,&#32;<link linkend="class_waveguide">Waveguide</link>&#32;*&#32;in_w)
102 {
103 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;r&#32;=&#32;NULL;
104 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;t&#32;=&#32;NULL;
105 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;q&#32;=&#32;NULL;
106 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;A&#32;=&#32;NULL;
107 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;&#32;B;
108 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;x,&#32;y;
109 &#32;&#32;std::complex&lt;double&gt;&#32;s(0.0,&#32;0.0);
110 
111 &#32;&#32;<emphasis class="keywordtype">int</emphasis>&#32;i,j;
112 
113 &#32;&#32;<emphasis class="comment">/*&#32;Load&#32;appropriate&#32;predefined&#32;table&#32;*/</emphasis>
114 &#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(i&#32;=&#32;0;&#32;i&lt;GSPHERESIZE;i++)
115 &#32;&#32;{
116 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">if</emphasis>(n==gsphere[i].n)
117 &#32;&#32;&#32;&#32;{
118 &#32;&#32;&#32;&#32;&#32;&#32;r&#32;=&#32;gsphere[i].r;
119 &#32;&#32;&#32;&#32;&#32;&#32;t&#32;=&#32;gsphere[i].t;
120 &#32;&#32;&#32;&#32;&#32;&#32;q&#32;=&#32;gsphere[i].q;
121 &#32;&#32;&#32;&#32;&#32;&#32;A&#32;=&#32;gsphere[i].A;
122 &#32;&#32;&#32;&#32;&#32;&#32;B&#32;=&#32;gsphere[i].B;
123 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordflow">break</emphasis>;
124 &#32;&#32;&#32;&#32;}
125 &#32;&#32;}
126 
127 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(NULL==r)&#32;<emphasis class="keywordflow">return</emphasis>&#32;-1.0;
128 
129 &#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(i=0;i&lt;n;i++)
130 &#32;&#32;{
131 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(j=0;j&lt;n;j++)
132 &#32;&#32;&#32;&#32;{
133 &#32;&#32;&#32;&#32;&#32;&#32;x&#32;=&#32;r[j]*q[i];
134 &#32;&#32;&#32;&#32;&#32;&#32;y&#32;=&#32;r[j]*t[i];
135 &#32;&#32;&#32;&#32;&#32;&#32;s&#32;+=&#32;A[j]*in_w-&gt;<link linkend="class_waveguide_1a79986c7554f0cd73cb13a3494caf6eab">evaluate_for_Position</link>(R*x-Xc,R*y-Yc,z);
136 &#32;&#32;&#32;&#32;}
137 &#32;&#32;}
138 
139 &#32;&#32;s&#32;*=&#32;R*R*B;
140 
141 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;s;
142 }
143 
144 std::complex&lt;double&gt;&#32;SpaceTransformation::evaluate_for_z_with_sum(<emphasis class="keywordtype">double</emphasis>&#32;in_z,&#32;<emphasis class="keywordtype">double</emphasis>&#32;in_r,&#32;<link linkend="class_waveguide">Waveguide</link>&#32;*&#32;in_w)&#32;{
145 &#32;&#32;std::complex&lt;double&gt;&#32;ret=&#32;0;
146 &#32;&#32;<emphasis class="keywordflow">try</emphasis>&#32;{
147 &#32;&#32;&#32;&#32;ret&#32;=&#32;gauss_product_2D_sphere(in_z,10,in_r,0,0,&#32;in_w);
148 &#32;&#32;}&#32;<emphasis class="keywordflow">catch</emphasis>&#32;(...)&#32;{
149 &#32;&#32;&#32;&#32;ret&#32;=&#32;0;
150 &#32;&#32;}
151 &#32;&#32;std::complex&lt;double&gt;&#32;b;
152 &#32;&#32;b.real(dealii::Utilities::MPI::sum(ret.real(),&#32;MPI_COMM_WORLD));
153 &#32;&#32;b.imag(dealii::Utilities::MPI::sum(ret.imag(),&#32;MPI_COMM_WORLD));
154 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;b;
155 }
156 
157 <emphasis class="preprocessor">#endif</emphasis>
    </computeroutput></literallayout>
</section>
