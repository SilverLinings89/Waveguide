<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_space_transformation_8cpp">
    <title>SpaceTransformation.cpp File Reference</title>
    <programlisting>#include &quot;SpaceTransformation.h&quot;</programlisting>
    <programlisting>#include &lt;deal.II/base/point.h&gt;</programlisting>
    <programlisting>#include &lt;deal.II/base/tensor.h&gt;</programlisting>
    <programlisting>#include &lt;deal.II/lac/vector.h&gt;</programlisting>
    <programlisting>#include &lt;complex&gt;</programlisting>
    <programlisting>#include &quot;../Core/Sector.h&quot;</programlisting>
    <programlisting>#include &quot;../Helpers/QuadratureFormulaCircle.cpp&quot;</programlisting>
    <programlisting>#include &quot;../Helpers/staticfunctions.h&quot;</programlisting>
        <section>
            <title>Macros</title>
            <para>
                <itemizedlist>
                    <listitem>
                            <para>#define <link linkend="_space_transformation_8cpp_1a0329e49292456d3f2835b1021307ff8d">SpaceTransformation_CPP</link></para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>
        <title>Detailed Description</title>
    <para>Definition in file /home/kraft/workspace/waveguideproblem/Code/SpaceTransformations/SpaceTransformation.cpp</para>
    </simplesect>
    <literallayout><computeroutput>
1 <emphasis class="preprocessor">#ifndef&#32;SpaceTransformation_CPP</emphasis>
2 <emphasis class="preprocessor">#define&#32;SpaceTransformation_CPP</emphasis>
3 
4 <emphasis class="preprocessor">#include&#32;&quot;SpaceTransformation.h&quot;</emphasis>
5 <emphasis class="preprocessor">#include&#32;&lt;deal.II/base/point.h&gt;</emphasis>
6 <emphasis class="preprocessor">#include&#32;&lt;deal.II/base/tensor.h&gt;</emphasis>
7 <emphasis class="preprocessor">#include&#32;&lt;deal.II/lac/vector.h&gt;</emphasis>
8 <emphasis class="preprocessor">#include&#32;&lt;complex&gt;</emphasis>
9 <emphasis class="preprocessor">#include&#32;&quot;../Core/Sector.h&quot;</emphasis>
10 <emphasis class="preprocessor">#include&#32;&quot;../Helpers/QuadratureFormulaCircle.cpp&quot;</emphasis>
11 <emphasis class="preprocessor">#include&#32;&quot;../Helpers/staticfunctions.h&quot;</emphasis>
12 
<link linkend="class_space_transformation_1af9803c5e0dc6947ae08e428d3953e914">13 </link>std::pair&lt;int,&#32;double&gt;&#32;<link linkend="class_space_transformation_1af9803c5e0dc6947ae08e428d3953e914">SpaceTransformation::Z_to_Sector_and_local_z</link>(
14 &#32;&#32;&#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;in_z)<emphasis class="keyword">&#32;const&#32;</emphasis>{
15 &#32;&#32;std::pair&lt;int,&#32;double&gt;&#32;ret;
16 &#32;&#32;ret.first&#32;=&#32;0;
17 &#32;&#32;ret.second&#32;=&#32;0.0;
18 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(in_z&#32;&lt;=&#32;-GlobalParams.M_R_ZLength&#32;/&#32;2.0)&#32;{
19 &#32;&#32;&#32;&#32;ret.first&#32;=&#32;0;
20 &#32;&#32;&#32;&#32;ret.second&#32;=&#32;0.0;
21 &#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;<emphasis class="keywordflow">if</emphasis>&#32;(abs(in_z)&#32;&lt;&#32;GlobalParams.M_R_ZLength&#32;/&#32;2.0)&#32;{
22 &#32;&#32;&#32;&#32;ret.first&#32;=&#32;floor((in_z&#32;+&#32;GlobalParams.M_R_ZLength&#32;/&#32;2.0)&#32;/
23 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(GlobalParams.SectorThickness));
24 &#32;&#32;&#32;&#32;ret.second&#32;=&#32;(in_z&#32;+&#32;GlobalParams.M_R_ZLength&#32;/&#32;2.0&#32;-
25 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(ret.first&#32;*&#32;GlobalParams.SectorThickness))&#32;/
26 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(GlobalParams.SectorThickness);
27 &#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;<emphasis class="keywordflow">if</emphasis>&#32;(in_z&#32;&gt;=&#32;GlobalParams.M_R_ZLength&#32;/&#32;2.0)&#32;{
28 &#32;&#32;&#32;&#32;ret.first&#32;=&#32;<link linkend="class_space_transformation_1ad0b9c36e4f79b481638b5f7ef4914f50">sectors</link>&#32;-&#32;1;
29 &#32;&#32;&#32;&#32;ret.second&#32;=&#32;1.0;
30 &#32;&#32;}
31 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;ret;
32 }
33 
34 SpaceTransformation::SpaceTransformation(<emphasis class="keywordtype">int</emphasis>&#32;in_dofs_per_layer,&#32;<emphasis class="keywordtype">int</emphasis>&#32;in_rank)
35 &#32;&#32;&#32;&#32;:&#32;dofs_per_layer(in_dofs_per_layer),
36 &#32;&#32;&#32;&#32;&#32;&#32;boundary_dofs_in(in_dofs_per_layer),
37 &#32;&#32;&#32;&#32;&#32;&#32;boundary_dofs_out(in_dofs_per_layer),
38 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1acfc3ce47223489b9261ee69d4fec6661">epsilon_K</link>(GlobalParams.M_W_epsilonin),
39 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1a3cb9e63fe3d5c4436236bd6fee69d060">epsilon_M</link>(GlobalParams.M_W_epsilonout),
40 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1ad0b9c36e4f79b481638b5f7ef4914f50">sectors</link>(GlobalParams.M_W_Sectors),
41 &#32;&#32;&#32;&#32;&#32;&#32;<link linkend="class_space_transformation_1a82a89fd12df1c0e1954c4a03115d2e42">deltaY</link>(GlobalParams.M_W_Delta),
42 &#32;&#32;&#32;&#32;&#32;&#32;rank(in_rank)&#32;{
43 &#32;&#32;<link linkend="class_space_transformation_1a881cfdd7ec955dd57a2b463ed4707662">InitialQuality</link>&#32;=&#32;0;
44 }
45 
<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">46 </link><emphasis class="keywordtype">double</emphasis>&#32;<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">SpaceTransformation::Sector_Length</link>()<emphasis class="keyword">&#32;const&#32;</emphasis>{
47 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;GlobalParams.SectorThickness;
48 }
49 
<link linkend="class_space_transformation_1a5c01731c41adb0a9e7881f890a838a0c">50 </link><emphasis class="keywordtype">int</emphasis>&#32;<link linkend="class_space_transformation_1a5c01731c41adb0a9e7881f890a838a0c">SpaceTransformation::Z_to_Layer</link>(<emphasis class="keywordtype">double</emphasis>&#32;in_z)<emphasis class="keyword">&#32;const&#32;</emphasis>{
51 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;temp&#32;=&#32;(in_z&#32;-&#32;GlobalParams.Minimum_Z)&#32;/&#32;GlobalParams.LayerThickness;
52 &#32;&#32;<emphasis class="keywordtype">int</emphasis>&#32;flr&#32;=&#32;floor(temp);
53 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(flr&#32;==&#32;0)&#32;{
54 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;0;
55 &#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;{
56 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(temp&#32;-&#32;flr&#32;&lt;&#32;0.000001)&#32;{
57 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;flr&#32;-&#32;1;
58 &#32;&#32;&#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;{
59 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;flr;
60 &#32;&#32;&#32;&#32;}
61 &#32;&#32;}
62 }
63 
64 <emphasis class="keywordtype">bool</emphasis>&#32;SpaceTransformation::is_identity(Point&lt;3,&#32;double&gt;&#32;coord)<emphasis class="keyword">&#32;const&#32;</emphasis>{
65 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;sum&#32;=&#32;0.0;
66 &#32;&#32;Point&lt;3,&#32;double&gt;&#32;temp&#32;=&#32;math_to_phys(coord);
67 &#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;3;&#32;i++)&#32;{
68 &#32;&#32;&#32;&#32;sum&#32;+=&#32;std::abs(temp[i]&#32;-&#32;coord[i]);
69 &#32;&#32;}
70 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;sum&#32;&lt;&#32;0.0001;
71 }
72 
73 std::pair&lt;double,&#32;double&gt;&#32;SpaceTransformation::dof_support(
74 &#32;&#32;&#32;&#32;<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;index)<emphasis class="keyword">&#32;const&#32;</emphasis>{
75 &#32;&#32;std::pair&lt;double,&#32;double&gt;&#32;ret;
76 &#32;&#32;ret.first&#32;=&#32;0.0;
77 &#32;&#32;ret.second&#32;=&#32;0.0;
78 &#32;&#32;<emphasis class="keywordtype">int</emphasis>&#32;boundary&#32;=&#32;index&#32;/&#32;dofs_per_layer;
79 &#32;&#32;ret.first&#32;=
80 &#32;&#32;&#32;&#32;&#32;&#32;-GlobalParams.M_R_ZLength&#32;/&#32;2.0&#32;+&#32;(boundary&#32;-&#32;1)&#32;*&#32;<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">Sector_Length</link>();
81 &#32;&#32;ret.second&#32;=&#32;ret.first&#32;+&#32;2&#32;*&#32;<link linkend="class_space_transformation_1a4719286bbc0bba23dcfa96badfb53ef1">Sector_Length</link>();
82 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;ret;
83 }
84 
85 <emphasis class="keywordtype">bool</emphasis>&#32;SpaceTransformation::point_in_dof_support(Point&lt;3&gt;&#32;location,
86 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;dof_index)<emphasis class="keyword">&#32;const&#32;</emphasis>{
87 &#32;&#32;std::pair&lt;double,&#32;double&gt;&#32;temp&#32;=&#32;dof_support(dof_index);
88 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(std::abs(location[2])&#32;&gt;&#32;GlobalParams.M_R_ZLength&#32;/&#32;2.0)&#32;{
89 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;<emphasis class="keyword">false</emphasis>;
90 &#32;&#32;}&#32;<emphasis class="keywordflow">else</emphasis>&#32;{
91 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;(temp.first&#32;&lt;=&#32;location[2]&#32;&amp;&amp;&#32;temp.second&#32;&gt;=&#32;location[2]);
92 &#32;&#32;}
93 }
94 
95 Tensor&lt;2,&#32;3,&#32;std::complex&lt;double&gt;&gt;&#32;SpaceTransformation::get_Tensor_for_step(
96 &#32;&#32;&#32;&#32;Point&lt;3&gt;&amp;&#32;coordinate,&#32;<emphasis class="keywordtype">unsigned</emphasis>&#32;<emphasis class="keywordtype">int</emphasis>&#32;dof,&#32;<emphasis class="keywordtype">double</emphasis>&#32;step_width)&#32;{
97 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;old_value&#32;=&#32;<link linkend="class_space_transformation_1a7d3a0e5a6084d3ed2c11772147eb1297">get_dof</link>(dof);
98 &#32;&#32;Tensor&lt;2,&#32;3,&#32;double&gt;&#32;trafo&#32;=&#32;get_Space_Transformation_Tensor(coordinate);
99 
100 &#32;&#32;Tensor&lt;2,&#32;3,&#32;std::complex&lt;double&gt;&gt;&#32;original&#32;=
101 &#32;&#32;&#32;&#32;&#32;&#32;Apply_PML_To_Tensor(coordinate,&#32;trafo);
102 &#32;&#32;<link linkend="class_space_transformation_1ae459d3c6f53143ec86773b87088cffcf">set_dof</link>(dof,&#32;old_value&#32;+&#32;step_width);
103 &#32;&#32;trafo&#32;=&#32;get_Space_Transformation_Tensor(coordinate);
104 &#32;&#32;Tensor&lt;2,&#32;3,&#32;std::complex&lt;double&gt;&gt;&#32;ret&#32;=
105 &#32;&#32;&#32;&#32;&#32;&#32;Apply_PML_To_Tensor(coordinate,&#32;trafo);
106 &#32;&#32;<link linkend="class_space_transformation_1ae459d3c6f53143ec86773b87088cffcf">set_dof</link>(dof,&#32;old_value);
107 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;ret&#32;-&#32;original;
108 }
109 
110 std::complex&lt;double&gt;&#32;SpaceTransformation::gauss_product_2D_sphere(
111 &#32;&#32;&#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;z,&#32;<emphasis class="keywordtype">int</emphasis>&#32;n,&#32;<emphasis class="keywordtype">double</emphasis>&#32;R,&#32;<emphasis class="keywordtype">double</emphasis>&#32;Xc,&#32;<emphasis class="keywordtype">double</emphasis>&#32;Yc,&#32;<link linkend="class_waveguide">Waveguide</link>*&#32;in_w)&#32;{
112 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;r&#32;=&#32;NULL;
113 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;t&#32;=&#32;NULL;
114 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;q&#32;=&#32;NULL;
115 &#32;&#32;<emphasis class="keywordtype">double</emphasis>*&#32;A&#32;=&#32;NULL;
116 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;B;
117 &#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;x,&#32;y;
118 &#32;&#32;std::complex&lt;double&gt;&#32;s(0.0,&#32;0.0);
119 
120 &#32;&#32;<emphasis class="keywordtype">int</emphasis>&#32;i,&#32;j;
121 
122 &#32;&#32;<emphasis class="comment">/*&#32;Load&#32;appropriate&#32;predefined&#32;table&#32;*/</emphasis>
123 &#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(i&#32;=&#32;0;&#32;i&#32;&lt;&#32;GSPHERESIZE;&#32;i++)&#32;{
124 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(n&#32;==&#32;gsphere[i].n)&#32;{
125 &#32;&#32;&#32;&#32;&#32;&#32;r&#32;=&#32;gsphere[i].r;
126 &#32;&#32;&#32;&#32;&#32;&#32;t&#32;=&#32;gsphere[i].t;
127 &#32;&#32;&#32;&#32;&#32;&#32;q&#32;=&#32;gsphere[i].q;
128 &#32;&#32;&#32;&#32;&#32;&#32;A&#32;=&#32;gsphere[i].A;
129 &#32;&#32;&#32;&#32;&#32;&#32;B&#32;=&#32;gsphere[i].B;
130 &#32;&#32;&#32;&#32;&#32;&#32;<emphasis class="keywordflow">break</emphasis>;
131 &#32;&#32;&#32;&#32;}
132 &#32;&#32;}
133 
134 &#32;&#32;<emphasis class="keywordflow">if</emphasis>&#32;(NULL&#32;==&#32;r)&#32;<emphasis class="keywordflow">return</emphasis>&#32;-1.0;
135 
136 &#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(i&#32;=&#32;0;&#32;i&#32;&lt;&#32;n;&#32;i++)&#32;{
137 &#32;&#32;&#32;&#32;<emphasis class="keywordflow">for</emphasis>&#32;(j&#32;=&#32;0;&#32;j&#32;&lt;&#32;n;&#32;j++)&#32;{
138 &#32;&#32;&#32;&#32;&#32;&#32;x&#32;=&#32;r[j]&#32;*&#32;q[i];
139 &#32;&#32;&#32;&#32;&#32;&#32;y&#32;=&#32;r[j]&#32;*&#32;t[i];
140 &#32;&#32;&#32;&#32;&#32;&#32;s&#32;+=&#32;A[j]&#32;*&#32;in_w-&gt;<link linkend="class_waveguide_1a79986c7554f0cd73cb13a3494caf6eab">evaluate_for_Position</link>(R&#32;*&#32;x&#32;-&#32;Xc,&#32;R&#32;*&#32;y&#32;-&#32;Yc,&#32;z);
141 &#32;&#32;&#32;&#32;}
142 &#32;&#32;}
143 
144 &#32;&#32;s&#32;*=&#32;R&#32;*&#32;R&#32;*&#32;B;
145 
146 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;s;
147 }
148 
149 std::complex&lt;double&gt;&#32;SpaceTransformation::evaluate_for_z_with_sum(
150 &#32;&#32;&#32;&#32;<emphasis class="keywordtype">double</emphasis>&#32;in_z,&#32;<emphasis class="keywordtype">double</emphasis>&#32;in_r,&#32;<link linkend="class_waveguide">Waveguide</link>*&#32;in_w)&#32;{
151 &#32;&#32;std::complex&lt;double&gt;&#32;ret&#32;=&#32;0;
152 &#32;&#32;<emphasis class="keywordflow">try</emphasis>&#32;{
153 &#32;&#32;&#32;&#32;ret&#32;=&#32;gauss_product_2D_sphere(in_z,&#32;10,&#32;in_r,&#32;0,&#32;0,&#32;in_w);
154 &#32;&#32;}&#32;<emphasis class="keywordflow">catch</emphasis>&#32;(...)&#32;{
155 &#32;&#32;&#32;&#32;ret&#32;=&#32;0;
156 &#32;&#32;}
157 &#32;&#32;std::complex&lt;double&gt;&#32;b;
158 &#32;&#32;b.real(dealii::Utilities::MPI::sum(ret.real(),&#32;MPI_COMM_WORLD));
159 &#32;&#32;b.imag(dealii::Utilities::MPI::sum(ret.imag(),&#32;MPI_COMM_WORLD));
160 &#32;&#32;<emphasis class="keywordflow">return</emphasis>&#32;b;
161 }
162 
163 <emphasis class="preprocessor">#endif</emphasis>
    </computeroutput></literallayout>
</section>
