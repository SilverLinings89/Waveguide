<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="class_waveguide">
<title>Waveguide class Reference</title>
<para>
    <programlisting>#include <link linkend="_waveguide_8h">&lt;Waveguide.h&gt;</link></programlisting>
</para>
        <section>
            <title>Public Attributes</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double * qualities</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>MeshGenerator * mg</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title>Private Attributes</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>SpaceTransformation * st</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>MPI_Comm mpi_comm</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>parallel::distributed::Triangulation&lt; 3 &gt;::active_cell_iterator cell</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>parallel::distributed::Triangulation&lt; 3 &gt;::active_cell_iterator endc</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FESystem&lt; 3 &gt; fe</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>parallel::distributed::Triangulation&lt; 3 &gt; triangulation</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector system_rhs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::BlockSparseMatrix system_matrix</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::BlockSparseMatrix prec_matrix_odd</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::BlockSparseMatrix prec_matrix_even</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const bool even</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>unsigned int rank</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FEValuesExtractors::Vector real</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>FEValuesExtractors::Vector imag</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>SolverControl solver_control</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConstraintMatrix cm</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConstraintMatrix cm_prec_even</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConstraintMatrix cm_prec_odd</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>DoFHandler&lt; 3 &gt; dof_handler</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_prec_even_owned_row</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_prec_even_owned_col</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_prec_even_writable</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_prec_odd_owned_row</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_prec_odd_owned_col</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_prec_odd_writable</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_sys_owned</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; i_sys_readable</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector primal_solution</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector dual_solution</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector * solution</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector EstimatedSolution</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector ErrorOfSolution</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet locally_owned_dofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet locally_relevant_dofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet locally_active_dofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet extended_relevant_dofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; locally_relevant_dofs_per_subdomain</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Vector&lt; double &gt; preconditioner_rhs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>LinearAlgebra::distributed::Vector&lt; double &gt; primal_with_relevant</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>LinearAlgebra::distributed::Vector&lt; double &gt; dual_with_relevant</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; locally_relevant_dofs_all_processors</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet UpperDofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet LowerDofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int run_number</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int condition_file_counter</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>int eigenvalue_file_counter</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const unsigned int Layers</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; int &gt; Dofs_Below_Subdomain</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; int &gt; Block_Sizes</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool is_stored</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>const int Sectors</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double minimum_local_z</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double maximum_local_z</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double locals_set</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::string path_prefix</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet fixed_dofs</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>long int solver_start_milis</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool primal</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConditionalOStream pout</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TimerOutput timer</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ExactSolution es</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::map&lt; types::global_dof_index, double &gt; dirichlet_data</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::map&lt; types::global_dof_index, double &gt; preconditioner_dirichlet_data_even</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::map&lt; types::global_dof_index, double &gt; preconditioner_dirichlet_data_odd</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConstraintMatrix boundary_value_constraints_imaginary</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConstraintMatrix boundary_value_constraints_real</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>ConstraintMatrix hanging_global</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector storage</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>TrilinosWrappers::MPI::BlockVector temp_storage</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::ofstream eigenvalue_file</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::ofstream condition_file</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::ofstream result_file</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::ofstream iteration_file</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; IndexSet &gt; set</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>bool execute_recomputation</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Vector&lt; float &gt; cell_weights</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Vector&lt; float &gt; cell_weights_prec_1</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Vector&lt; float &gt; cell_weights_prec_2</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet locally_owned_cells</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet sweepable</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="class_waveguide_1aacf2484e402aa1afc05b1b278ea8ce73">Waveguide</link> (
MPI_Comm in_mpi_comm, <link linkend="class_mesh_generator">MeshGenerator</link> * in_mg, <link linkend="class_space_transformation">SpaceTransformation</link> * in_st)<para><emphasis>This is the constructor that should be used to initialize objects of this type.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para> <link linkend="class_waveguide_1a731dc250d3465795312c7414c9ff0311">~Waveguide</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a50cf6893286ff8b1b4955f98df0194d2">run</link> (
)<para><emphasis>This method as well as the rerun() method, are used by the optimization-algorithm to use and reuse the Waveguide-object.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1ac393acf22cbd722518c449e977824713">assemble_part</link> (
)<para><emphasis>The assemble_part(unsigned int in_part) function is a part of the assemble_system() functionality.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::complex&lt; double &gt; <link linkend="class_waveguide_1a79986c7554f0cd73cb13a3494caf6eab">evaluate_for_Position</link> (
double x, double y, double z)<para><emphasis>To compute the output quality of the signal and it&apos;s transmition along the waveguid-axis, this function performs a comparison of the fundamental mode of a waveguide and the actual situation.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_waveguide_1aa8d0471156e3b8b969b5d26dc2db98f3">evaluate_for_z</link> (
double )<para><emphasis>To compute the output quality of the signal and it&apos;s transmition along the waveguid-axis, this function performs a comparison of the fundamental mode of a waveguide and the actual situation.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a78d46797f2fcf1aa43310bf98c87b83e">evaluate</link> (
)<para><emphasis>This function has the purpose of filling the qualities array in every process with the appropriate Values from the other ones.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a3c6bc7f419f94b50c85edbd917c550d1">store</link> (
)<para><emphasis>The storage has the following purpose: Regarding the optimization-process there are two kinds of runs.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1aecce672b929c81b8966198043bff646a">estimate_solution</link> (
)<para><emphasis>This function is currently not in use.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::vector&lt; std::complex&lt; double &gt; &gt; <link linkend="class_waveguide_1af05d7473f76f9e1d2dd49e82fe072f8a">assemble_adjoint_local_contribution</link> (
double stepwidth)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1ad60aed44304bd6590dc34a630b134d6a">switch_to_primal</link> (
<link linkend="class_space_transformation">SpaceTransformation</link> * primal_st)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a12999f5678f485975471abb06760b339">switch_to_dual</link> (
<link linkend="class_space_transformation">SpaceTransformation</link> * dual_st)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Point&lt; 3, double &gt; <link linkend="class_waveguide_1a0584ba2d2a1e027d79551cd1e28f8d9e">transform_coordinate</link> (
const Point&lt; 3, double &gt; )</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section>
            <title></title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a93f9cd6d24502e61a354c943808a0061">make_grid</link> (
)<para><emphasis>Grid-generation is a crucial part of any FEM-Code.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1ae2cd9522a7b46a2a50edb8df8aca40d1">setup_system</link> (
)<para><emphasis>In this function, the first case-specific data is used.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a5ceba704e2d31be61c08d8f8ad105eae">assemble_system</link> (
)<para><emphasis>Assemble system is the function to build a system-matrix.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1acb47bc05db1424a2fb08d90b4ed45efb">solve</link> (
)<para><emphasis>Upon successful assembly of the system-matrix, the solution has to be calculated.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1af29661c9638aa793f0eff09692c3a1cc">reset_changes</link> (
)<para><emphasis>In case no differential implementation is used (this means, that in every step of both the optimization and the calculation of the gradient, the system-matrix and all other elements are completely rebuilt) this function is used, to clear all values out of the data-objects.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1aae6de6026641c23029faa5c0fc26d019">output_results</link> (
bool details)<para><emphasis>This function takes the Waveguides solution-vector member and exports it in a .vtk-file along with the mesh-structure to make the results visible.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a5a8bed1a0db5082d9589fa341c7c0d05">print_eigenvalues</link> (
const std::vector&lt; std::complex&lt; double &gt;&gt; &amp; )<para><emphasis>This function is used bz the GMRE-solvers in deal.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a2483d366ceae565a30ae2341bcd958c4">print_condition</link> (
double )<para><emphasis>Similar to the functio print_eigenvalues(const std::vector&lt;std::complex&lt;double&gt;&gt; &amp;) , this function uses step-results of the GMRES-solver to make properties of the system-matrix available.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>SolverControl::State <link linkend="class_waveguide_1a7b59eb1b20d03076ccd180cfc1b4e15a">check_iteration_state</link> (
const unsigned int, const double , const dealii::TrilinosWrappers::MPI::Vector &amp; )<para><emphasis>This function occupies one slot of the Solver and will generate formatted output on the console and write the convergence history to a file.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1acf90b894904c9f392ee6b90a2ad9aa41">MakeBoundaryConditions</link> (
)<para><emphasis>This function fills the ConstraintMatrix-object of the Waveguide-object with all constraints needed for condensation into the szstem-matrix.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a6aeeead3e873b27499ca9542f9ed29ee">MakePreconditionerBoundaryConditions</link> (
)<para><emphasis>This function generates the Constraint-Matrices for the two Preconditioner Matrices.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a8d9f2467a6115437bc8555c03780a84b">Compute_Dof_Numbers</link> (
)<para><emphasis>This function executes refined downstream ordering of degrees of freedom.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a411d4001eb24d2be2d787bf010bc30f7">Prepare_Boundary_Constraints</link> (
)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>double <link linkend="class_waveguide_1a6d7f56316fe15510f16a8274dda70589">RHS_value</link> (
const Point&lt; 3 &gt; &amp; , const unsigned int component)<para><emphasis>DEPRECATED.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; <link linkend="class_waveguide_1ad1d80bf8fe0393f741c37b45099ba457">Conjugate_Tensor</link> (
Tensor&lt; 2, 3, std::complex&lt; double &gt;&gt; input)<para><emphasis>This function returns the transposed and complex conjugated Matrix for the given Matrix.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 1, 3, std::complex&lt; double &gt; &gt; <link linkend="class_waveguide_1aa21b8f8cd7ae015ccc63abdd966fc043">Conjugate_Vector</link> (
Tensor&lt; 1, 3, std::complex&lt; double &gt;&gt; input)<para><emphasis>This function calculates the complex conjugate of every vector entry and returns the result in a copy.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1ae840385ae2e073fe33f1f4c17306298e">reinit_all</link> (
)<para><emphasis>Reinit all datastorage objects.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a04f1d6703207d7f7d8d036aa0cb091fb">reinit_rhs</link> (
)<para><emphasis>Reinit only the right hand side vector.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a736d6f21b2ba33a778a3af5e86abf511">reinit_preconditioner</link> (
)<para><emphasis>Reinit only the PML-Matrix which is used in the construction of the Preconditioner.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a9ce54e6ccc7d98c56742388e10c2db4a">reinit_systemmatrix</link> (
)<para><emphasis>Reinit only the system matrix.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1aec58220e99ae874c4745027a30f6798a">reinit_cell_weights</link> (
)<para><emphasis>The cell weights can be used to store any scalar information about each cell of the mesh.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a8057013d1836e2282f7de6fd2c8340a2">calculate_cell_weights</link> (
)<para><emphasis>In calculate cell weights an arbitrary value for each cell can be computed and then this value can be sent to the output to generate a plot of it.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1add93c68596c48cb5f21d63d3f0382ea4">reinit_solution</link> (
)<para><emphasis>Reinit only the solution vector.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a86c25b3cd839b01ff6864eff6701ff87">reinit_storage</link> (
)<para><emphasis>This function only initializes the storage vector.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1ad5455dd56074cacba7ce904f2335cea9">reinit_for_rerun</link> (
)<para><emphasis>When a run has already been completed, not all data structures need to be completely be rebuilt.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a6005bda52cf5adf9dc1ab8f0669b579d">reinit_preconditioner_fast</link> (
)<para><emphasis>Similar to the function reinit_for_rerun but focused on the data structures used by the preconditioner.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>SolverControl::State <link linkend="class_waveguide_1a7d1eb933d45991d5ee862cd682690cce">residual_tracker</link> (
unsigned int Iteration, double resiudal, dealii::TrilinosWrappers::MPI::BlockVector vec)<para><emphasis>While the solver runs, this function performs an action on the residual.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>std::complex&lt; double &gt; <link linkend="class_waveguide_1a2b1181fe82eeef848a95ac11b700f5f5">gauss_product_2D_sphere</link> (
double z, int n, double R, double Xc, double Yc)<para><emphasis>This function encapsulates a library call for 2D numeric integration over a circle with given properties.</emphasis></para>
</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 1, 3, std::complex&lt; double &gt; &gt; <link linkend="class_waveguide_1a1f4d993446816cbcf54aa54a327507be">solution_evaluation</link> (
Point&lt; 3, double &gt; position)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a7377f829012982460f66ece07e12758e">solution_evaluation</link> (
Point&lt; 3, double &gt; position, double * solution)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Tensor&lt; 1, 3, std::complex&lt; double &gt; &gt; <link linkend="class_waveguide_1ab9980c0b0aa53179b7ece5ddcd333e3d">adjoint_solution_evaluation</link> (
Point&lt; 3, double &gt; position)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>void <link linkend="class_waveguide_1a6e0126ca2911a6022b9e8a9fd18937c0">adjoint_solution_evaluation</link> (
Point&lt; 3, double &gt; position, double * solution)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>IndexSet <link linkend="class_waveguide_1a477acc7900984f59f89860354cce20c5">combine_indexes</link> (
IndexSet lower, IndexSet upper)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    <simplesect>

<para>This class encapsulates all important mechanism for solving a FEM problem. </para>
    </simplesect>
        <simplesect>
            <title>Detailed Description</title>

<para>In earlier versions this also included space transformation and computation of materials. Now it only includes FEM essentials and solving the system matrix.</para>

<para>Upon initialization it requires structural information about the waveguide that will be simulated. The object then continues to initialize the FEM-framework. After allocating space for all objects, the assemblation-process of the system-matrix begins. Following this step, the user-selected preconditioner and solver are used to solve the system and generate outputs. This class is the core piece of the implementation.</para>

<para><formalpara><title>Author: </title>

<para>Pascal Kraft </para>
</formalpara>
<formalpara><title>Date: </title>

<para>03.07.2016 </para>
</formalpara>
</para>
                <para>Definition at line 97 of file Waveguide.h</para>
                <para>The Documentation for this struct was generated from the following file: </para>
                <para><itemizedlist><listitem><para>Waveguide.h</para></listitem></itemizedlist></para>
        </simplesect>
        <section>
            <title>Member Data Documentation</title>
        </section>
        <section>
            <title>Member Data Documentation</title>
        </section>
            <section xml:id="class_waveguide_1aacf2484e402aa1afc05b1b278ea8ce73">
                <title>Waveguide::Waveguide (MPI_Comm in_mpi_comm, MeshGenerator *in_mg, SpaceTransformation *in_st)</title> <emphasis>This is the constructor that should be used to initialize objects of this type.</emphasis>
                
<para>
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>param</entry>
                                <entry>
<para>This is a reference to a parsed form of the input-file. </para>
</entry>
                            </row>
                            <row>
                                <entry>structure</entry>
                                <entry>
<para>This parameter gives a reference to the structure of the real <link linkend="class_waveguide">Waveguide</link>. This is necessary since during matrix-assembly it is required to call a function which generates the transformation tensor which is purely structure-dependent. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_waveguide_1a731dc250d3465795312c7414c9ff0311">
                <title>Waveguide::~Waveguide ()</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a50cf6893286ff8b1b4955f98df0194d2">
                <title>void Waveguide::run ()</title> <emphasis>This method as well as the rerun() method, are used by the optimization-algorithm to use and reuse the Waveguide-object.</emphasis>
                
<para>Since the system-matrix consumes a lot of memory it makes sense to reuse it, rather then creating a new one for every optimization step. All properties of position[2]the object have to be created properly for this function to work. </para>

            </section>
            <section xml:id="class_waveguide_1ac393acf22cbd722518c449e977824713">
                <title>void Waveguide::assemble_part ()</title> <emphasis>The assemble_part(unsigned int in_part) function is a part of the assemble_system() functionality.</emphasis>
                
<para>It builds a part of the system-matrix. assemble_system() creates the global system matrix. After splitting the degrees of freedom into several block, this method takes one block (identified by the integer passed as an argument) and calculates all matrix-entries that reference it. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>in_part</entry>
                                <entry>
<para>Numerical identifier of the part of the system. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                <formalpara><title>Date: </title>

<para>13.11.2015 </para>
</formalpara>
<formalpara><title>Author: </title>

<para>Pascal Kraft </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_waveguide_1a79986c7554f0cd73cb13a3494caf6eab">
                <title>std::complex&lt; double &gt; Waveguide::evaluate_for_Position (double x, double y, double z)</title> <emphasis>To compute the output quality of the signal and it&apos;s transmition along the waveguid-axis, this function performs a comparison of the fundamental mode of a waveguide and the actual situation.</emphasis>
                
<para>For this purpose we integrate the product of the two functions over a cross-section of the waveguide in transformed coordinates. To perform this action we need to use numeric integration so the integral is decomposed into a sum over local evaluations. For this to be possible this function can be handed x,y and z coordinates and returns the according value. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>x</entry>
                                <entry>
<para>gives the x-coordinate. </para>
</entry>
                            </row>
                            <row>
                                <entry>y</entry>
                                <entry>
<para>gives the y-coordinate. </para>
</entry>
                            </row>
                            <row>
                                <entry>z</entry>
                                <entry>
<para>gives the z-coordinate. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_waveguide_1aa8d0471156e3b8b969b5d26dc2db98f3">
                <title>double Waveguide::evaluate_for_z (double)</title> <emphasis>To compute the output quality of the signal and it&apos;s transmition along the waveguid-axis, this function performs a comparison of the fundamental mode of a waveguide and the actual situation.</emphasis>
                
<para>For this purpose we integrate the product of the two functions over a cross-section of the waveguide in transformed coordinates. To perform this action we need to use numeric integration so the integral is decomposed into a sum over local evaluations. For this to be possible this function can be handed x,y and z coordinates and returns the according value. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>x</entry>
                                <entry>
<para>gives the x-coordinate. </para>
</entry>
                            </row>
                            <row>
                                <entry>y</entry>
                                <entry>
<para>gives the y-coordinate. </para>
</entry>
                            </row>
                            <row>
                                <entry>z</entry>
                                <entry>
<para>gives the z-coordinate. </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_waveguide_1a78d46797f2fcf1aa43310bf98c87b83e">
                <title>void Waveguide::evaluate ()</title> <emphasis>This function has the purpose of filling the qualities array in every process with the appropriate Values from the other ones.</emphasis>
                
<para>Now it will become necessary to build an optimization-scheme ontop, which can handle this information on process one and then distribute a new shape to the others. The function will use the Waveguide-Property execute_rebuild to signal a need for recomputation. </para>

            </section>
            <section xml:id="class_waveguide_1a3c6bc7f419f94b50c85edbd917c550d1">
                <title>void Waveguide::store ()</title> <emphasis>The storage has the following purpose: Regarding the optimization-process there are two kinds of runs.</emphasis>
                
<para>The first one, taking place with no knowledge of appropriate starting values for the degrees of freedom, and the following steps, in which the prior results can be used to estimate appropriate starting values for iterative solvers as well as the preconditioner. This function switches the behaviour in the following way: Once it is called, it stores the current solution in a run-independent variable, making it available for later runs. Also it sets a flag, indicating, that prior solutions are now available for usage in the solution process. </para>

            </section>
            <section xml:id="class_waveguide_1aecce672b929c81b8966198043bff646a">
                <title>void Waveguide::estimate_solution ()</title> <emphasis>This function is currently not in use.</emphasis>
                
<para>It is supposed to create a useful input-vector for the first step of the iteration. However currently this is not used, since current cases simply use a zero-vector for the first step and previous solutions in the subsequent steps. </para>

            </section>
            <section xml:id="class_waveguide_1af05d7473f76f9e1d2dd49e82fe072f8a">
                <title>std::vector&lt; std::complex&lt; double &gt; &gt; Waveguide::assemble_adjoint_local_contribution (double stepwidth)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1ad60aed44304bd6590dc34a630b134d6a">
                <title>void Waveguide::switch_to_primal (SpaceTransformation *primal_st)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a12999f5678f485975471abb06760b339">
                <title>void Waveguide::switch_to_dual (SpaceTransformation *dual_st)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a0584ba2d2a1e027d79551cd1e28f8d9e">
                <title>Point&lt; 3, double &gt; Waveguide::transform_coordinate (const Point&lt; 3, double &gt;)</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a93f9cd6d24502e61a354c943808a0061">
                <title>void Waveguide::make_grid ()</title> <emphasis>Grid-generation is a crucial part of any FEM-Code.</emphasis>
                
<para>This function holds all functionality concerning that topic. In the current implementation we start with a cubic Mesh. That mesh originally is subdivided in 5 cells per dimension yielding a total of 5*5*5 = 125 cells. The central cells in the x-z planes are given a cylindrical manifold-description forcing them to interpolate the new points during global refinement using a circular shape rather than linear interpolation. This leads to the description of a cylinder included within a cube. There are currently three techniques for mesh-refinement:<orderedlist>
<listitem>
<para>Global refinement: For such refinement-cases, any cell is subdivided in the middle of any dimension. In this case every cell is split into 8 new ones, increasing the number of cells massively. Pros: no hanging nodes. Cons: Very many new dofs that might be in areas, where the resolution of the mesh is already large enough.</para>
</listitem><listitem>
<para>Inner refinement: In this case, only degrees that were in the original core-cells, will be refined. These are cells, which in the real physical simulation are part of the waveguide-core rather then the mantle.</para>
</listitem><listitem>
<para>Boundary-refinement: In this case, cells are refined, that are close to the boundary of the waveguide (not close to the boundary of the computational domain!). To see the used definition of close, please see the code.</para>
</listitem></orderedlist>
</para>

<para>Following the creation of the mesh, the dofs are distributed to it using the function setup_system(). This function only has to be used once even in optimization runs since the mesh can be reused for every run. This saves a lot of time especially for large cases and distributed calculations. </para>

            </section>
            <section xml:id="class_waveguide_1ae2cd9522a7b46a2a50edb8df8aca40d1">
                <title>void Waveguide::setup_system ()</title> <emphasis>In this function, the first case-specific data is used.</emphasis>
                
<para>First off we number the degrees of freedom. After completion of this task we start making boundary-conditions. The creation of appropriate boundary-conditions is twofold: #- Mathematical boundary conditions as described in the literature on this matter. In this case we use Dirichlet boundary values that are either zero-values or alternatively are calculated from the mode-distribution of the incoming signal. #- Numerical constraints from hanging nodes. The non-global refinement steps cause hanging-nodes that have to be constrained to their neighbors. This problem can be solved automatically by deal and uses the same mechanism (constraints) as mathematical boundary values do.</para>

<para>Constraint Matrixes (as constructed in this function) can be used primarily in two ways. Documentation concerning this problem can be found at <link xlink:href="https://www.dealii.org/developer/doxygen/deal.II/group__constraints.html">Constraints On Degrees Of Freedom</link>. </para>

            </section>
            <section xml:id="class_waveguide_1a5ceba704e2d31be61c08d8f8ad105eae">
                <title>void Waveguide::assemble_system ()</title> <emphasis>Assemble system is the function to build a system-matrix.</emphasis>
                
<para>This can either happen incrementally or from scratch depending on if a solution has been stored before or not. Essentially it splits the system in blocks and then calls assemble_block(unsigned int index) for the individual blocks. This function will have to be improved for incremental building of the system matrix in order to proceed to upcoming versions. <formalpara><title>Author: </title>

<para>Pascal Kraft </para>
</formalpara>
<formalpara><title>Date: </title>

<para>16.11.2015 </para>
</formalpara>
</para>

            </section>
            <section xml:id="class_waveguide_1acb47bc05db1424a2fb08d90b4ed45efb">
                <title>void Waveguide::solve ()</title> <emphasis>Upon successful assembly of the system-matrix, the solution has to be calculated.</emphasis>
                
<para>This is done in this function. There are multiple Templates of this function for enabling switching between libraries. The Dealii implementation uses deal&apos;s native solvers as well as data-types. The other templated editions use the PETSc and Trilinos equivalents. The type of solver to be used and its parameters are specified via the parameter GYU </para>

            </section>
            <section xml:id="class_waveguide_1af29661c9638aa793f0eff09692c3a1cc">
                <title>void Waveguide::reset_changes ()</title> <emphasis>In case no differential implementation is used (this means, that in every step of both the optimization and the calculation of the gradient, the system-matrix and all other elements are completely rebuilt) this function is used, to clear all values out of the data-objects.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1aae6de6026641c23029faa5c0fc26d019">
                <title>void Waveguide::output_results (bool details)</title> <emphasis>This function takes the Waveguides solution-vector member and exports it in a .vtk-file along with the mesh-structure to make the results visible.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a5a8bed1a0db5082d9589fa341c7c0d05">
                <title>void Waveguide::print_eigenvalues (const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;)</title> <emphasis>This function is used bz the GMRE-solvers in deal.</emphasis>
                
<para>This solver uses the iteration-results to estimate the eigenvalues and this function is used via handle to use them. In this function, the eigenvalues are simply pushed into a file. </para>

            </section>
            <section xml:id="class_waveguide_1a2483d366ceae565a30ae2341bcd958c4">
                <title>void Waveguide::print_condition (double)</title> <emphasis>Similar to the functio print_eigenvalues(const std::vector&lt;std::complex&lt;double&gt;&gt; &amp;) , this function uses step-results of the GMRES-solver to make properties of the system-matrix available.</emphasis>
                
<para>In this case it is the condition number, estimated on the basis of said eigenvalues, that gets pushed to a file also. </para>

            </section>
            <section xml:id="class_waveguide_1a7b59eb1b20d03076ccd180cfc1b4e15a">
                <title>SolverControl::State Waveguide::check_iteration_state (const unsigned int, const double, const dealii::TrilinosWrappers::MPI::Vector &amp;)</title> <emphasis>This function occupies one slot of the Solver and will generate formatted output on the console and write the convergence history to a file.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1acf90b894904c9f392ee6b90a2ad9aa41">
                <title>void Waveguide::MakeBoundaryConditions ()</title> <emphasis>This function fills the ConstraintMatrix-object of the Waveguide-object with all constraints needed for condensation into the szstem-matrix.</emphasis>
                
<para>It&apos;s properties are derived from the <link linkend="class_waveguide">Waveguide</link> itself and the Waveguide-Structure-object available to it, therefore there are no parameters but those members need to be prepared accordingly.. </para>

            </section>
            <section xml:id="class_waveguide_1a6aeeead3e873b27499ca9542f9ed29ee">
                <title>void Waveguide::MakePreconditionerBoundaryConditions ()</title> <emphasis>This function generates the Constraint-Matrices for the two Preconditioner Matrices.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a8d9f2467a6115437bc8555c03780a84b">
                <title>void Waveguide::Compute_Dof_Numbers ()</title> <emphasis>This function executes refined downstream ordering of degrees of freedom.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a411d4001eb24d2be2d787bf010bc30f7">
                <title>void Waveguide::Prepare_Boundary_Constraints ()</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a6d7f56316fe15510f16a8274dda70589">
                <title>double Waveguide::RHS_value (const Point&lt; 3 &gt; &amp;, const unsigned int component)</title> <emphasis>DEPRECATED.</emphasis>
                
<para>SCHEDULED FOR REMOVAL. </para>

            </section>
            <section xml:id="class_waveguide_1ad1d80bf8fe0393f741c37b45099ba457">
                <title>Tensor&lt; 2, 3, std::complex&lt; double &gt; &gt; Waveguide::Conjugate_Tensor (Tensor&lt; 2, 3, std::complex&lt; double &gt;&gt; input)</title> <emphasis>This function returns the transposed and complex conjugated Matrix for the given Matrix.</emphasis>
                
<para>The function operates on a copy, it doesn&apos;t change the arguments value. 
                <formalpara>
                    <title/>
                    <table frame="all">
                        <title>Parameters                        </title>
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
                                <entry>input</entry>
                                <entry>
<para>This is the order 2 Tensor (Matrix) to be transposed ( <equation><title>form_22</title>$a_{ij} = a&apos;{ji}$</equation>) and complex conjugated ( <equation><title>form_23</title>$\operatorname{Im}(a_{ij}) = - \operatorname{Im}(a&apos;_{ji})$</equation>) </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                </formalpara>
                </para>

            </section>
            <section xml:id="class_waveguide_1aa21b8f8cd7ae015ccc63abdd966fc043">
                <title>Tensor&lt; 1, 3, std::complex&lt; double &gt; &gt; Waveguide::Conjugate_Vector (Tensor&lt; 1, 3, std::complex&lt; double &gt;&gt; input)</title> <emphasis>This function calculates the complex conjugate of every vector entry and returns the result in a copy.</emphasis>
                
<para>Similar to Conjugate_Tensor(Tensor&lt;2,3, std::complex&lt;double&gt;&gt; input) this function does not operate in place - it operates on a copy and hence returns a new object. </para>

            </section>
            <section xml:id="class_waveguide_1ae840385ae2e073fe33f1f4c17306298e">
                <title>void Waveguide::reinit_all ()</title> <emphasis>Reinit all datastorage objects.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a04f1d6703207d7f7d8d036aa0cb091fb">
                <title>void Waveguide::reinit_rhs ()</title> <emphasis>Reinit only the right hand side vector.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a736d6f21b2ba33a778a3af5e86abf511">
                <title>void Waveguide::reinit_preconditioner ()</title> <emphasis>Reinit only the PML-Matrix which is used in the construction of the Preconditioner.</emphasis>
                
<para>This should only be used if the need for space is there. Otherwise this matrix while being a temporary object, is very large. </para>

            </section>
            <section xml:id="class_waveguide_1a9ce54e6ccc7d98c56742388e10c2db4a">
                <title>void Waveguide::reinit_systemmatrix ()</title> <emphasis>Reinit only the system matrix.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1aec58220e99ae874c4745027a30f6798a">
                <title>void Waveguide::reinit_cell_weights ()</title> <emphasis>The cell weights can be used to store any scalar information about each cell of the mesh.</emphasis>
                
<para>This reinit-function prepares the data structures for its usage. </para>

            </section>
            <section xml:id="class_waveguide_1a8057013d1836e2282f7de6fd2c8340a2">
                <title>void Waveguide::calculate_cell_weights ()</title> <emphasis>In calculate cell weights an arbitrary value for each cell can be computed and then this value can be sent to the output to generate a plot of it.</emphasis>
                
<para>An example for this procedure is the computation of the norm of the material tensor to check it&apos;s validity across the mesh. </para>

            </section>
            <section xml:id="class_waveguide_1add93c68596c48cb5f21d63d3f0382ea4">
                <title>void Waveguide::reinit_solution ()</title> <emphasis>Reinit only the solution vector.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a86c25b3cd839b01ff6864eff6701ff87">
                <title>void Waveguide::reinit_storage ()</title> <emphasis>This function only initializes the storage vector.</emphasis>
                
<para>Keep in mind, that a call to this function is <emphasis>not</emphasis> included in reinit_all(). </para>

            </section>
            <section xml:id="class_waveguide_1ad5455dd56074cacba7ce904f2335cea9">
                <title>void Waveguide::reinit_for_rerun ()</title> <emphasis>When a run has already been completed, not all data structures need to be completely be rebuilt.</emphasis>
                
<para>They only need to be emptied. This function does just that. </para>

            </section>
            <section xml:id="class_waveguide_1a6005bda52cf5adf9dc1ab8f0669b579d">
                <title>void Waveguide::reinit_preconditioner_fast ()</title> <emphasis>Similar to the function reinit_for_rerun but focused on the data structures used by the preconditioner.</emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a7d1eb933d45991d5ee862cd682690cce">
                <title>SolverControl::State Waveguide::residual_tracker (unsigned int Iteration, double resiudal, dealii::TrilinosWrappers::MPI::BlockVector vec)</title> <emphasis>While the solver runs, this function performs an action on the residual.</emphasis>
                
<para>In the most common use case this action is to print it to the console or to push it to some data stream. </para>

            </section>
            <section xml:id="class_waveguide_1a2b1181fe82eeef848a95ac11b700f5f5">
                <title>std::complex&lt;double&gt; Waveguide::gauss_product_2D_sphere (double z, int n, double R, double Xc, double Yc)</title> <emphasis>This function encapsulates a library call for 2D numeric integration over a circle with given properties.</emphasis>
                
<para>It is included that this function calls evaluate_for_Position(x,y,z) </para>

            </section>
            <section xml:id="class_waveguide_1a1f4d993446816cbcf54aa54a327507be">
                <title>Tensor&lt; 1, 3, std::complex&lt; double &gt; &gt; Waveguide::solution_evaluation (Point&lt; 3, double &gt; position) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a7377f829012982460f66ece07e12758e">
                <title>void Waveguide::solution_evaluation (Point&lt; 3, double &gt; position, double *solution) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1ab9980c0b0aa53179b7ece5ddcd333e3d">
                <title>Tensor&lt; 1, 3, std::complex&lt; double &gt; &gt; Waveguide::adjoint_solution_evaluation (Point&lt; 3, double &gt; position) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a6e0126ca2911a6022b9e8a9fd18937c0">
                <title>void Waveguide::adjoint_solution_evaluation (Point&lt; 3, double &gt; position, double *solution) const</title> <emphasis></emphasis>
                
            </section>
            <section xml:id="class_waveguide_1a477acc7900984f59f89860354cce20c5">
                <title>IndexSet Waveguide::combine_indexes (IndexSet lower, IndexSet upper) const</title> <emphasis></emphasis>
                
            </section>
</section>
