/**
 * @file PMLSurface.h
 * @author Pascal Kraft (kraft.pascal@gmail.com)
 * @brief Implementation of the PML Surface class.
 * @version 0.1
 * @date 2022-03-22
 * 
 * @copyright Copyright (c) 2022
 * 
 */

#include "../Core/Types.h"
#include "./BoundaryCondition.h"
#include <deal.II/fe/fe_nedelec_sz.h>
#include <deal.II/lac/affine_constraints.h>
#include "./PMLMeshTransformation.h"

/**
 * @brief An implementation of a UPML method.
 * 
 * This is one of the core objects in the entire implementation. For an explanation of the PML method, please read \cref{subsec:PML}.
 * 
 * This object assembles matrix blocks for our system that act as an absorbing boundary condition. In essence, the object builds a mesh for the PML domain and uses Nedelec elements on it to compute the matrix entries.
 * Additionally, it can fill a sparsity pattern with the information about which dofs couple to which and it also manages its own dofs, i.e. the ones that aren't also dofs on the inner domain. The object additionally sets the PEC boundary conditions \cref{subsec:PEC} on the outside boundary of the PML domain.
 * If a neighboring boundary condition also uses PML, this object is capable of building a connecting mesh of the corner or edge domains to couple the systems together.
 * The method can use either a constant value for the imaginary part of the material tensor or a ramping value of arbitrary order. 
 * 
 * Mesh geometry:
 * The inner domain is a cube of say 10x10x10 cells. This method primarily builds an extension of that geometry in one direction. We choose one boundary (specified by b_id) and connect an additional domain with the inner domain. This additional domain shares the same cell counts in the surface tangential directions and has a specified thickness, which is a global parameter. Lets assume this thickness is 5.
 * If the b_id is 5, i.e. this PML surface is handling the +z surface of the inner domain, then the PML domain will have 10x10x5 cells (the 5 in the third component because z direction). An important point is the following: 
 * If say boundary id 3 (+y) also uses PML and has such an extension, then we need to somehow couple the dofs of the PML domain for b_id 5 facing towards +y and the boundary dofs of the PML domain for b_id 3 facing towards +z together. To facilitate this, we introduce a connecting domain, an edge domain. This edge domain will have 10x5x5 cells.
 * The same problem arises if we add another PML domain on the surface for b_id 1 (+x). All three PML domains discussed so far share a corner which we have to discretize by 5x5x5 cells. 
 * 
 * To be able to easily ectract the boundary degrees of freedom, we rely on coloring, i.e. a cached value on each edge indicating to which surface it belongs. This can then be used to quickly retrieve dof indices for boundaries. 
 * To make this possible, we itterate over the mesh and check for relevant structures (cell, face and edge centers) if they are located at the relevant surfaces. Also: We want all dofs to be owend by one process / object. As a consequence, the connecting corner and edge domains are assembled by one side, not shared. Edge and corner domains are always owned by the boundary condition with the higher b_id (this makes sense in cobination with sweeping).
 * If a mesh is extended in a direction, we use the method is_position_at_extended_boundary, otherwise we use is_position_at_boundary.
 * 
 * The shape of these PML domains can be seen in the output generated by this code since the solution on PML domains is written to seperate output files.
 * 
 * As a special implementation detail it should be noted, that the cell layer touching the inner domain does not use the material tensor with imaginary part. It is instead treated as normal computational domain.
 */
class PMLSurface : public BoundaryCondition {
    ComplexNumber sigma_0;
    unsigned int inner_boundary_id;
    unsigned int outer_boundary_id;
    dealii::FE_NedelecSZ<3> fe_nedelec;
    PMLMeshTransformation transformation;
    bool mesh_is_transformed;
    const double surface_coordinate;
    std::array<std::vector<InterfaceDofData>, 6> dof_associations;
    std::array<std::pair<double,double>, 3> lower_pml_ranges;
    std::array<std::pair<double,double>, 3> upper_pml_ranges;
    double effective_pml_thickness;

  public: 
    std::pair<double, double> x_range;
    std::pair<double, double> y_range;
    std::pair<double, double> z_range;
    double non_pml_layer_thickness; // thickness of the cell layer closest to the surface. Here I set the transformation tensor to 0 to ensure surface dofs are not damped.
    dealii::Triangulation<3> triangulation;
    
    PMLSurface(unsigned int in_bid, unsigned int in_level);
    ~PMLSurface();
    
    /**
     * @brief Checks if the provided coordinate is at the provided boundary. 
     * 
     * @return true if the point is at that boundary.
     * @return false if not.
     */
    bool is_point_at_boundary(Position, BoundaryId);

    /**
     * @brief For this method we use PEC boundary conditions on the outside of the PML domain. This function writes the dof constraints representing those PEC constraints to an empty Affine Constraints object and returns it.
     * 
     * As described in \cref{subsec:PML}, we apply PEC boundary conditions, i.e. dirichlet zero values for the tangential trace on the surface of the PML domain that is facing outward. The affined constraints object we build here can be used to condense the system matrix to set the constrained dofs to the right value.
     * 
     * @return Constraints The constraint object to be used anywhere in the code to condense a system or to update vector values.
     */
    auto make_constraints() -> Constraints override;

    /**
     * @brief Writes the FE system of this PML domain to a provided system matrix and rhs vector using the constraints. 
     * 
     * This is part of the default assembly cycle of dealii.
     * 
     * @param matrix The sytem matrix to write into.
     * @param rhs The right-hand side vector (rhs) to write into.
     * @param constraints The constraints to consider while writing.
     */
    void fill_matrix(dealii::PETScWrappers::MPI::SparseMatrix* matrix, NumericVectorDistributed* rhs, Constraints *constraints) override;

    /**
     * @brief Sets the locations of actually coupling dofs to non-zero in a sparsity pattern so we know to reserve memory for it.
     * 
     * The function also uses a provided constraints object to make this operation more efficient. If, for example, a dof is set to zero, we don't need to store values in the system matrix row and column relating to it.
     * 
     * This is part of the default assembly cycle of dealii.
     * 
     * @param in_dsp The sparsity pattern to fill with the entries.
     * @param in_constriants Constraints to consider.
     */
    void fill_sparsity_pattern(dealii::DynamicSparsityPattern *in_dsp, Constraints * in_constriants) override;

    /**
     * @brief Checks if a 2D position of the surface mesh is  also at another boundary, i.e. an edge of the inner domain.
     * 
     * @param in_p The position to check for.
     * @param in_bid The boundary Id we check for.
     * @return true If the provided position is at that boundary id.
     * @return false If not.
     */
    bool is_point_at_boundary(Position2D in_p, BoundaryId in_bid) override;

    /**
     * @brief This function and the next are used to color the surfaces of the PML domain.
     * 
     * See the class description for details.
     * 
     * @param in_p 
     * @param in_bid 
     * @return true 
     * @return false  
     */
    bool is_position_at_boundary(const Position in_p, const BoundaryId in_bid);

    /**
     * @brief This function and the previous one a re used to color the surfaces of the PML domain.
     * 
     * See the class description for details.
     * 
     * @param in_p 
     * @param in_bid 
     * @return true 
     * @return false 
     */
    bool is_position_at_extended_boundary(const Position in_p, const BoundaryId in_bid);

    /**
     * @brief Initializes the data structures to reserve memory.
     * 
     * This function is part of the default dealii assembly loop.
     * 
     */
    void initialize() override;

    /**
     * @brief Set the mesh boundary ids by checking if faces and edges are at certain boundaries. After this is called, we can retrieve dofs by boundary id.
     * 
     */
    void set_mesh_boundary_ids(); 

    /**
     * @brief Builds the mesh of the PML domain and corner/edge connecting domains.
     * 
     */
    void prepare_mesh();

    /**
     * @brief Counts the number of cells at a boundary id.
     * 
     * @param boundary_id The boundary to search on.
     * @return unsigned int The number of cells.
     */
    auto cells_for_boundary_id(unsigned int boundary_id) -> unsigned int override;

    /**
     * @brief Initializes all the parts of the finite element loop like the dof handler and the finite element object that provides shape functions.
     * 
     * See the deal.ii documentation on this since it is oriented on their structure of fe computations.
     * 
     */
    void init_fe();

    /**
     * @brief Computes the fraction of the PML thickness of the provided position for the computation of sigma for all three space directions.
     * 
     * As described in \cref{subsec:PML}, we can ramp up the value of sigma as we approach the outer boundary to reduce the effect of reflections by a profile like \cref{eqn:PMLIncrease}. In this equation, this function computes z/d for all three directions and returns them.
     * 
     * @return std::array<double, 3> 
     */
    auto fraction_of_pml_direction(Position) -> std::array<double, 3> ;

    /**
     * @brief Get the PML material tensor \epsilon_p for a given position.
     * 
     * This is \epsilon_p in \cref{sec:PML}.
     * 
     * @param in_p The location to compute the material tensor at
     * @return dealii::Tensor<2,3,ComplexNumber> The material tensor \epsilon_p for a UPML medium at a given location.
     */
    auto get_pml_tensor_epsilon(Position in_p) -> dealii::Tensor<2,3,ComplexNumber>;

    /**
     * @brief Get the PML material tensor \mu_p for a given position.
     * 
     * This is \mu_p in \cref{sec:PML}.
     * 
     * @param in_p The location to compute the material tensor at
     * @return dealii::Tensor<2,3,ComplexNumber> The material tensor \mu_p for a UPML medium at a given location.
     */
    auto get_pml_tensor_mu(Position in_p) -> dealii::Tensor<2,3,ComplexNumber>;

    /**
     * @brief Internal function that computes the purely geometric transformation tensor.
     * 
     * @return dealii::Tensor<2,3,ComplexNumber> 
     */
    auto get_pml_tensor(Position) -> dealii::Tensor<2,3,ComplexNumber>;

    /**
     * @brief Get the degrees of freedom associated with the interface to the inner domain.
     * 
     * @return std::vector<InterfaceDofData> Vector of all dofs and their base points.
     */
    auto get_dof_association() -> std::vector<InterfaceDofData> override;

    /**
     * @brief Get the degrees of freedom associated with either the inner domain or another boundary conditions domain.
     * 
     * @param in_boundary_id The other boundary id. If this is b_id, this returns the same as get_dof_association().
     * @return std::vector<InterfaceDofData> Vector of all dofs and their base points.
     */
    auto get_dof_association_by_boundary_id(BoundaryId in_boundary_id) -> std::vector<InterfaceDofData> override;

    /**
     * @brief Internal function to compute the coordinate ranges of the domain occupied by this UPML domain.
     * 
     * @param in_tria 
     */
    void compute_coordinate_ranges(dealii::Triangulation<3> * in_tria);

    /**
     * @brief Color the mesh surfaces.
     * This function updates the local mesh to set the boundary ids of all outside faces.
     */
    void set_boundary_ids();

    /**
     * @brief Inverts vertex and edge orders to switch the sign of the cell volumes.
     * 
     * Currently, this should not be required.
     * 
     * @param in_tria The triangulation to perform the operation on.
     */
    void fix_apply_negative_Jacobian_transformation(dealii::Triangulation<3> * in_tria);

    /**
     * @brief Writes an output file for paraview of the solution provided projected onto the local mesh.
     * 
     * @param solution_vector The fe solution vector to be used.
     * @param filename Fragment of the filename to be used (this will be extended by process and boundary ids for uniqueness)
     * @return The filename of the generated file
     * 
     */
    std::string output_results(const dealii::Vector<ComplexNumber> & solution_vector, std::string filename) override;

    /**
     * @brief Performs basic tests on the meshes to check if they are valid.
     */
    void validate_meshes();

    /**
     * @brief Counts the locally owned dofs.
     * 
     * @return DofCount the number of the dofs that are locally owned.
     */
    DofCount compute_n_locally_owned_dofs() override;

    /**
     * @brief Counts the locally active dofs.
     * 
     * @return DofCount the number of the dofs that are locally active.
     */
    DofCount compute_n_locally_active_dofs() override;

    /**
     * @brief Iterates over all surfaces of the PML domain and sets the dof indices if the surface is not locally owned.
     * This function should be nilpotent and only called during setup. It is purely internal and not mathematically relevant.
     * 
     */
    void finish_dof_index_initialization() override;

    /**
     * @brief Marks all non-owned dofs in the is_dof_locally_owned array.
     * 
     */
    void determine_non_owned_dofs() override;

    /**
     * @brief Generates an dealii::IndexSet of all non locally owned dofs.
     * 
     * @return dealii::IndexSet The IndexSet of non-owned dofs.
     */
    dealii::IndexSet compute_non_owned_dofs();

    /**
     * @brief Given a first index, this function numbers the owned dofs starting at that number.
     * 
     * @param first_own_index The first locally owned index will receive this index.
     * @return true If all indices now have a valid global index.
     * @return false There are still indices that are not numbered.
     */
    bool finish_initialization(DofNumber first_own_index) override;

    /**
     * @brief Checks if the PML requires an extension domain towards the boundary with BoundaryId b_id and, if so, creates a mesh of that extension and provides it in the pointer argument.
     * 
     * @param return_pointer The pointer to be used to store the extension triangulation in.
     * @param b_id The boundary toward which we are checking for an extension
     * @return true The PML domain requires extension here and the extension is stored in return_pointer
     * @return false No extension is required.
     */
    bool mg_process_edge(dealii::Triangulation<3> * return_pointer, BoundaryId b_id);

    /**
     * @brief Same as above but for edges. Therefore requires two boundary ids.
     * 
     * @param return_pointer The pointer to be used to store the extension triangulation in.
     * @param first_bid 
     * @param second_bid 
     * @return true This corner requires an extension domain, i.e. there are PML boundaries on the other two boundaries and the extension is locally owned.
     * @return false Either no domain is required or it is not locally owned.
     */
    bool mg_process_corner(dealii::Triangulation<3> * current_list, BoundaryId first_bid, BoundaryId second_bid);

    /**
     * @brief Check if an extension domain is required towards the boundary in_bid
     * 
     * @param in_bid The other boundary to be checked towards
     * @return true 
     * @return false 
     */
    bool extend_mesh_in_direction(BoundaryId in_bid);

    /**
     * @brief Caches the association of dofs with the surfaces so it can be accessed cheaper in the future.
     * 
     */
    void prepare_dof_associations();

    /**
     * @brief Counts the number of local cells.
     * 
     * @return unsigned int 
     */
    unsigned int n_cells() override;
};